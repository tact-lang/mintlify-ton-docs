---
title: "Testing reference"
---

Blueprint provides comprehensive testing capabilities for TON smart contracts using the TON Sandbox emulator and test utilities. This reference covers all available testing APIs, methods, and utilities.

## Quick Navigation

TODO:

**Related Documentation:**
- [Blueprint testing overview](/ecosystem/blueprint/testing/overview) — getting started with testing
- [Testing guidelines](/ecosystem/blueprint/testing/testing-guidelines) — best practices and patterns
- [Testing on real network](/ecosystem/blueprint/testing/testing-on-real-network) — mainnet/testnet testing
- [Blueprint benchmarks](/ecosystem/blueprint/benchmarks) — performance testing and optimization

## Environment setup

Blueprint testing environment requires proper setup of the TON Sandbox and test utilities.

### Installation

```bash
npm install --save-dev @ton/sandbox @ton/test-utils
```

### Basic test structure

```typescript title="./tests/Sample.spec.ts" expandable
import { Blockchain, SandboxContract, TreasuryContract } from '@ton/sandbox';
import { Cell, toNano } from '@ton/core';
import { Sample } from '../wrappers/Sample';
import '@ton/test-utils';
import { compile } from '@ton/blueprint';

describe('Sample', () => {
    let code: Cell;

    beforeAll(async () => {
        code = await compile('Sample');
    });

    let blockchain: Blockchain;
    let deployer: SandboxContract<TreasuryContract>;
    let sample: SandboxContract<Sample>;

    beforeEach(async () => {
        blockchain = await Blockchain.create();

        sample = blockchain.openContract(Sample.createFromConfig({}, code));

        deployer = await blockchain.treasury('deployer');

        const deployResult = await sample.sendDeploy(deployer.getSender(), toNano('0.05'));

        expect(deployResult.transactions).toHaveTransaction({
            from: deployer.address,
            to: sample.address,
            deploy: true,
            success: true,
        });
    });

    it('should deploy', async () => {
        // the check is done inside beforeEach
        // blockchain and sample are ready to use
    });
});
```

## Core Testing Classes

### `Blockchain`

Main blockchain emulator class that provides isolated testing environment.

```typescript
class Blockchain {
    static create(opts?: {
        executor?: IExecutor;
        config?: BlockchainConfig;
        storage?: BlockchainStorage;
        meta?: ContractsMeta;
        autoDeployLibs?: boolean;
    }): Promise<Blockchain>

    // Contract and states management
    treasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>>
    createWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]>
    openContract<T extends Contract>(contract: T): SandboxContract<T>
    provider(address: Address, init?: StateInit | null): ContractProvider
    sender(address: Address): Sender
    getContract(address: Address): Promise<SmartContract>
    setShardAccount(address: Address, account: ShardAccount): Promise<void>
    getTransactions(address: Address, opts?: { limit?: number; lt?: string | bigint; hash?: string | Buffer }): Promise<BlockchainTransaction[]>

    // Core messaging methods
    sendMessage(message: Message | Cell, params?: MessageParams): Promise<SendMessageResult>
    sendMessageIter(message: Message | Cell, params?: SendMessageIterParams): Promise<AsyncIterator<BlockchainTransaction> & AsyncIterable<BlockchainTransaction>>
    runGetMethod(address: Address, method: number | string, stack?: TupleItem[], params?: GetMethodParams): Promise<GetMethodResult>
    runTickTock(on: Address | Address[], which: TickOrTock, params?: MessageParams): Promise<SendMessageResult>

    // Snapshotting
    snapshot(): BlockchainSnapshot
    loadFrom(snapshot: BlockchainSnapshot): Promise<void>

    // Coverage
    enableCoverage(enable?: boolean): void
    coverage(contract: Contract): Coverage | undefined
    coverageForCell(code: Cell, address?: Address): Coverage | undefined

    // Debugging
    getDebuggerExecutor(): Promise<Executor>
    get debug(): boolean
    set debug(value: boolean)

    // Configuration methods
    setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void>
    setConfig(config: BlockchainConfig): void
    randomize(): Promise<Buffer>

    // Configuration properties
    get now(): number | undefined
    set now(now: number | undefined)
    get lt(): bigint
    get config(): Cell
    get configBase64(): string
    get verbosity(): LogsVerbosity
    set verbosity(value: LogsVerbosity)
    get libs(): Cell | undefined
    set libs(value: Cell | undefined)
    get random(): Buffer | undefined
    set random(value: Buffer | undefined)
    get recordStorage(): boolean
    set recordStorage(v: boolean)
    get autoDeployLibraries(): boolean
    set autoDeployLibraries(value: boolean)
    get prevBlocks(): PrevBlocksInfo | undefined
    set prevBlocks(value: PrevBlocksInfo | undefined)
}
```

#### `Blockchain.create()`

```typescript
static create(opts?: {
    executor?: IExecutor;
    config?: BlockchainConfig;
    storage?: BlockchainStorage;
    meta?: ContractsMeta;
    autoDeployLibs?: boolean;
}): Promise<Blockchain>
```

Creates a new blockchain instance for testing.

**Parameters:**
- `opts` — optional blockchain configuration
  - `executor` — custom contract executor (default: `Executor`)
  - `config` — blockchain configuration (`Cell`, `'default'`, or `'slim'`)
  - `storage` — contracts storage (default: `LocalBlockchainStorage`)
  - `meta` — optional contracts metadata provider
  - `autoDeployLibs` — automatically collect and deploy libraries

**Returns:** promise resolving to blockchain instance

**Usage example:**
```typescript
// Basic blockchain
const blockchain = await Blockchain.create();

// With slim config for faster execution
const blockchain = await Blockchain.create({ config: 'slim' });

// With remote storage
const blockchain = await Blockchain.create({
    storage: new RemoteBlockchainStorage(client)
});

// With auto-deploy libraries
const blockchain = await Blockchain.create({
    autoDeployLibs: true
});
```

#### `treasury()`

```typescript
treasury(seed: string, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>>
```

Creates a treasury wallet contract. This wallet is used as alternative to wallet smart contract.

**Parameters:**
- `seed` — initial seed for treasury. If the same seed is used to create a treasury, then these treasuries will be identical
- `params` — optional treasury parameters
  - `workchain` — the workchain ID of the treasury (default: 0)
  - `predeploy` — if set the treasury will be deployed on the moment of creation
  - `balance` — initial balance of the treasury (default: 1_000_000 TON if omitted)
  - `resetBalanceIfZero` — if set and treasury balance is zero on moment of calling method it reset balance to `balance`

**Returns:** promise resolving to treasury contract wrapper

**Usage example:**
```typescript
const deployer = await blockchain.treasury('deployer');
const user = await blockchain.treasury('user', { balance: toNano('100') });

// Same seed creates identical treasury
const wallet1 = await blockchain.treasury('same-seed');
const wallet2 = await blockchain.treasury('same-seed');
// wallet1.address equals wallet2.address
```

#### `createWallets()`

```typescript
createWallets(n: number, params?: TreasuryParams): Promise<SandboxContract<TreasuryContract>[]>
```

Bulk variant of `treasury()` method.

**Parameters:**
- `n` — number of wallets to create
- `params` — params for treasury creation

**Returns:** array of opened treasury contracts

**Usage example:**
```typescript
const [wallet1, wallet2, wallet3] = await blockchain.createWallets(3);
```

#### `openContract()`

```typescript
openContract<T extends Contract>(contract: T): SandboxContract<T>
```

Wraps a contract for testing with additional methods and state tracking.

**Parameters:**
- `contract` — contract instance to wrap

**Returns:** `SandboxContract` wrapper with testing capabilities

**Usage example:**
```typescript
const myContract = blockchain.openContract(MyContract.createFromConfig(config, code));
```

#### `provider()`

```typescript
provider(address: Address, init?: StateInit | null): ContractProvider
```

Creates new `ContractProvider` for contract address.

**Parameters:**
- `address` — address to create contract provider for
- `init` — initial state of contract

**Returns:** ContractProvider instance

**Usage example:**
```typescript
const contractProvider = blockchain.provider(address, init);
```

#### `sender()`

```typescript
sender(address: Address): Sender
```

Creates Sender for address. Note, that this sender pushes internal messages to Blockchain directly. No value is deducted from sender address, all the values are set to defaults. Use for test purposes only.

**Parameters:**
- `address` — address to create sender for

**Returns:** `Sender` instance

**Usage example:**
```typescript
const sender = blockchain.sender(address);
await contract.send(sender, ...);
```

#### `getContract()`

```typescript
getContract(address: Address): Promise<SmartContract>
```

Retrieves `SmartContract` from `BlockchainStorage`.

**Parameters:**
- `address` — address of contract to get

**Returns:** promise resolving to `SmartContract` instance

#### `setShardAccount()`

```typescript
setShardAccount(address: Address, account: ShardAccount): Promise<void>
```

Sets the account state directly for a contract address.

**Parameters:**
- `address` — contract address
- `account` — shard account state to set

#### `getTransactions()`

```typescript
getTransactions(address: Address, opts?: {
    limit?: number;
    lt?: string | bigint;
    hash?: string | Buffer;
}): Promise<BlockchainTransaction[]>
```

Retrieves transactions for the specified address. Transactions are ordered from newest to oldest.

**Parameters:**
- `address` — the address to retrieve transactions for
- `opts` — options to fetch transactions
    - `lt` — logical time of the transaction to start from (must be used with `hash`)
    - `hash` — hash of the transaction to start from (must be used with `lt`)
    - `limit` — maximum number of transactions to return

**Returns:** promise resolving to array of transactions involving the given address

**Usage example:**
```typescript
const transactions = await blockchain.getTransactions(Address.parse('...'), {
    lt: '1234567890',
    hash: 'abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890',
    limit: 10
});
```

#### `sendMessage()`

```typescript
sendMessage(message: Message | Cell, params?: MessageParams): Promise<SendMessageResult>
```

Emulates the result of sending a message to this `Blockchain`. Emulates the whole chain of transactions before returning the result. Each transaction increases lt by 1000000.

**Parameters:**
- `message` — message to send (`Message` object or `Cell` for external messages)
- `params` — optional `MessageParams`
  - `now` — override blockchain time for this message
  - `randomSeed` — random seed for deterministic execution
  - `ignoreChksig` — whether `CHKSIG` instructions are set to always succeed. Default: `false`

**Returns:** promise resolving to `SendMessageResult` containing transactions, events, and externals

**Usage example:**
```typescript
const result = await blockchain.sendMessage(internal({
    from: sender.address,
    to: contract.address,
    value: toNano('1'),
    body: beginCell().storeUint(0, 32).endCell(),
}));

// Check transactions
expect(result.transactions).toHaveTransaction({
    from: sender.address,
    to: contract.address,
    success: true
});
```

#### `sendMessageIter()`

```typescript
sendMessageIter(message: Message | Cell, params?: SendMessageIterParams): Promise<AsyncIterator<BlockchainTransaction> & AsyncIterable<BlockchainTransaction>>
```

Starts emulating the result of sending a message to this Blockchain. Each iterator call emulates one transaction, so the whole chain is not emulated immediately, unlike in `sendMessage`.

**Parameters:**
- `message` — message to send
- `params` — optional parameters
    - `allowParallel` — when `true`, allows many consequential executions of this method (default: `false`)
    - other `MessageParams` (now, randomSeed, ignoreChksig)

**Returns:** promise resolving to async iterator of BlockchainTransaction

**Usage example:**
```typescript
const message = internal({
    from: sender.address,
    to: address,
    value: toNano('1'),
    body: beginCell().storeUint(0, 32).endCell(),
});

for await (const tx of await blockchain.sendMessageIter(message, { randomSeed: crypto.randomBytes(32) })) {
    // process transaction
    console.log(tx);
}
```

#### `runGetMethod()`

```typescript
runGetMethod(address: Address, method: number | string, stack?: TupleItem[], params?: GetMethodParams): Promise<GetMethodResult>
```

Runs get method on contract.

**Parameters:**
- `address` — contract address
- `method` — method ID (number) or method name (string) to run
- `stack` — method parameters as TupleItem array
- `params` — optional execution parameters
  - `now` — override blockchain time for this call
  - `randomSeed` — random seed for deterministic execution
  - `gasLimit` — overrides TVM emulator `gas_limit`, defaults to 10_000_000

**Returns:** promise resolving to GetMethodResult with stackReader and other execution details

**Usage example:**
```typescript
const { stackReader } = await blockchain.runGetMethod(address, 'get_now', [], {
    now: 2,
});
const now = stackReader.readNumber();

// With method ID
const result = await blockchain.runGetMethod(address, 123, []);
```

#### `runTickTock()`

```typescript
runTickTock(on: Address | Address[], which: TickOrTock, params?: MessageParams): Promise<SendMessageResult>
```

Runs tick or tock transaction.

**Parameters:**
- `on` — address or addresses to run tick-tock
- `which` — type of transaction (`'tick'` or `'tock'`)
- `params` — `MessageParams` (now, randomSeed, ignoreChksig)

**Returns:** promise resolving to SendMessageResult

**Usage example:**
```typescript
let res = await blockchain.runTickTock(address, 'tock');
```

#### `snapshot()`

```typescript
snapshot(): BlockchainSnapshot
```

Saves snapshot of current blockchain.

**Returns:** blockchain snapshot object

**Usage example:**
```typescript
const snapshot = blockchain.snapshot();
// some operations
await blockchain.loadFrom(snapshot); // restores blockchain state
```

#### `loadFrom()`

```typescript
loadFrom(snapshot: BlockchainSnapshot): Promise<void>
```

Restores blockchain state from snapshot.

**Parameters:**
- `snapshot` — snapshot of blockchain

**Usage example:**
```typescript
const snapshot = blockchain.snapshot();
// ... perform operations
await blockchain.loadFrom(snapshot);
```

#### `enableCoverage()`

```typescript
enableCoverage(enable?: boolean): void
```

Enable coverage collection.

**Parameters:**
- `enable` — if `false`, disable coverage collection (default: `true`)

**Usage example:**
```typescript
blockchain.enableCoverage();
// ... execute contract methods
const coverage = blockchain.coverage(contract);
```

#### `coverage()`

```typescript
coverage(contract: Contract): Coverage | undefined
```

Returns coverage analysis for the specified contract. Coverage is collected at the TVM assembly instruction level from all executed transactions and get method calls.

**Parameters:**
- `contract` — contract to analyze coverage for

**Returns:** `Coverage` object with detailed coverage data or undefined

**Throws:** `Error` if the contract has no code or if verbose VM logs are not enabled

**Usage example:**
```typescript
blockchain.enableCoverage();
await contract.send(sender, { value: toNano('1') }, 'increment');

const coverage = blockchain.coverage(contract);
const summary = coverage?.summary();
console.log(`Coverage: ${summary?.coveragePercentage?.toFixed(2)}%`);

const htmlReport = coverage?.report("html");
await fs.writeFile("coverage.html", htmlReport);
```

#### `coverageForCell()`

```typescript
coverageForCell(code: Cell, address?: Address): Coverage | undefined
```

Returns coverage analysis for the specified code cell. This method allows analyzing coverage for code cells directly, with optional address filtering.

**Parameters:**
- `code` — Cell containing contract code to analyze
- `address` — optional contract address to filter transactions by

**Returns:** Coverage object with detailed coverage data

**Usage example:**
```typescript
blockchain.enableCoverage();
const coverage = blockchain.coverageForCell(codeCell, contractAddress);
const allCoverage = blockchain.coverageForCell(codeCell); // Without address filtering
```

#### `getDebuggerExecutor()`

```typescript
getDebuggerExecutor(): Promise<Executor>
```

Gets the debugger executor instance for debugging purposes.

**Returns:** promise resolving to Executor instance for debugging

**Usage example:**
```typescript
const debugExecutor = await blockchain.getDebuggerExecutor();
// Use debugExecutor for debugging operations
```

#### `debug`

```typescript
get debug(): boolean
set debug(value: boolean)
```

Gets or sets debug mode for the blockchain.

#### `setVerbosityForAddress()`

```typescript
setVerbosityForAddress(address: Address, verbosity: Partial<LogsVerbosity> | Verbosity | undefined): Promise<void>
```

Updates logs verbosity level for address.

**Parameters:**
- `address` — contract address
- `verbosity` — verbosity configuration or undefined to reset

**Usage example:**
```typescript
await blockchain.setVerbosityForAddress(contract.address, {
    blockchainLogs: true,
    vmLogs: 'vm_logs_full'
});
```

#### `setConfig()`

```typescript
setConfig(config: BlockchainConfig): void
```

Updates blockchain config.

**Parameters:**
- `config` — custom config in Cell format, or predefined `'default'` | `'slim'`

**Usage example:**
```typescript
blockchain.setConfig('slim'); // Use slim config for faster execution
blockchain.setConfig(customConfigCell); // Use custom config
```

#### `randomize()`

```typescript
randomize(): Promise<Buffer>
```

Generates and sets a new random seed using secure random bytes.

**Returns:** promise resolving to the generated random seed `Buffer`

**Usage example:**
```typescript
const newSeed = await blockchain.randomize();
```

#### `now`

```typescript
get now(): number | undefined
set now(now: number | undefined)
```

Gets or sets the current time in the blockchain (UNIX timestamp).

**Usage example:**
```typescript
// Get current time
const currentTime = blockchain.now;

// Set blockchain time
blockchain.now = Math.floor(Date.now() / 1000);

// Clear time (use system time)
blockchain.now = undefined;
```

#### `lt`

```typescript
get lt(): bigint
```

Gets the current logical time in the blockchain.

**Returns:** current logical time as `bigint`

#### `config`

```typescript
get config(): Cell
```

Gets the configuration used in the blockchain.

**Returns:** configuration as Cell

#### `configBase64`

```typescript
get configBase64(): string
```

Gets the configuration used in the blockchain in base64 format.

**Returns:** configuration as base64 string

#### `verbosity`

```typescript
get verbosity(): LogsVerbosity
set verbosity(value: LogsVerbosity)
```

Gets or sets the logs verbosity level.

**Usage example:**
```typescript
// Get current verbosity
const currentVerbosity = blockchain.verbosity;

// Set verbosity
blockchain.verbosity = {
    print: true,
    blockchainLogs: true,
    vmLogs: 'vm_logs_full',
    debugLogs: true
};
```

#### `libs`

```typescript
get libs(): Cell | undefined
set libs(value: Cell | undefined)
```

Gets or sets the global blockchain libraries.

**Usage example:**
```typescript
// Get current libs
const currentLibs = blockchain.libs;

// Set libraries
const libsDict = Dictionary.empty(Dictionary.Keys.Buffer(32), Dictionary.Values.Cell());
libsDict.set(libCell.hash(), libCell);
blockchain.libs = beginCell().storeDictDirect(libsDict).endCell();
```

#### `random`

```typescript
get random(): Buffer | undefined
set random(value: Buffer | undefined)
```

Gets or sets the random seed.

**Usage example:**
```typescript
// Get current random seed
const currentSeed = blockchain.random;

// Set random seed
blockchain.random = crypto.randomBytes(32);
```

#### `recordStorage`

```typescript
get recordStorage(): boolean
set recordStorage(v: boolean)
```

If set to `true`, `BlockchainTransaction` will have `oldStorage` and `newStorage` fields. Note that enabling this flag will disable a certain optimization, which will slow down contract emulation.

#### `autoDeployLibraries`

```typescript
get autoDeployLibraries(): boolean
set autoDeployLibraries(value: boolean)
```

Gets or sets whether libraries should be automatically deployed.

#### `prevBlocks`

```typescript
get prevBlocks(): PrevBlocksInfo | undefined
set prevBlocks(value: PrevBlocksInfo | undefined)
```

Gets or sets the `PrevBlocksInfo` for the blockchain.

### `Treasury`

Test treasury wallet for sending transactions and managing test funds. Treasury is created by `blockchain.treasury()` and provides a convenient wallet interface for testing.

```typescript
class TreasuryContract implements Contract {
    static readonly code: Cell;
    static create(workchain: number, subwalletId: bigint): TreasuryContract;
    readonly address: Address;
    readonly init: StateInit;
    readonly subwalletId: bigint;
    constructor(workchain: number, subwalletId: bigint);
    sendMessages(provider: ContractProvider, messages: MessageRelaxed[], sendMode?: SendMode): Promise<void>;
    send(provider: ContractProvider, args: SenderArguments): Promise<void>;
    getSender(provider: ContractProvider): Treasury;
    getBalance(provider: ContractProvider): Promise<bigint>;
    createTransfer(args: {
        messages: MessageRelaxed[];
        sendMode?: SendMode;
    }): Cell;
}

type Treasury = SandboxContract<TreasuryContract>
```

#### `code`

```typescript
static readonly code: Cell
```

Static property containing the compiled treasury contract code.

**Returns:** Cell with treasury contract bytecode

#### `create()`

```typescript
static create(workchain: number, subwalletId: bigint): TreasuryContract
```

Creates a new treasury contract instance.

**Parameters:**
- `workchain` — workchain ID (typically 0)
- `subwalletId` — unique subwallet identifier

**Returns:** new TreasuryContract instance

#### `address`

```typescript
readonly address: Address
```

The address of the treasury contract.

**Returns:** `Address` of the treasury

#### `init`

```typescript
readonly init: StateInit
```

The initial state of the treasury contract.

**Returns:** `StateInit` for contract deployment

#### `subwalletId`

```typescript
readonly subwalletId: bigint
```

Unique subwallet identifier generated from the treasury seed using SHA-256.

**Returns:** bigint subwallet ID

#### `sendMessages()`

```typescript
sendMessages(provider: ContractProvider, messages: MessageRelaxed[], sendMode?: SendMode): Promise<void>
```

Sends multiple messages via the treasury contract.

**Parameters:**
- `provider` — contract provider
- `messages` — array of messages to send
- `sendMode` — optional send mode (default: pay gas fees separately)

#### `send()`

```typescript
send(provider: ContractProvider, args: SenderArguments): Promise<void>
```

Sends a single message via the treasury contract.

**Parameters:**
- `provider` — contract provider
- `args` — sender arguments including value, body, and send mode

#### `getSender()`

```typescript
getSender(): Sender
```

#### `getBalance()`

```typescript
getBalance(provider: ContractProvider): Promise<bigint>;
```

Returns a sender interface for this treasury that automatically handles sending transactions.

**Returns:** `Sender` object for transaction signing

**Usage example:**
```typescript
const deployer = await blockchain.treasury('deployer');
const sender = deployer.getSender();

// Sender automatically handles seqno and signing
await contract.sendDeploy(sender, toNano('0.05'));
```

#### `createTransfer()`

```typescript
createTransfer(args: {
    messages: MessageRelaxed[];
    sendMode?: SendMode;
}): Cell
```

Creates a transfer message cell for sending multiple messages via the treasury.

**Parameters:**
- `args` — transfer arguments
  - `messages` — array of messages to include in transfer
  - `sendMode` — optional send mode (default: pay gas fees separately)

**Returns:** Cell containing the transfer message body

#### Treasury usage

Treasury contracts are pre-funded wallets that work like regular wallet contracts:

**Usage example:**
```typescript
// Create treasury with default 1M TON balance
const treasury = await blockchain.treasury('user');

// Create treasury with custom balance
const richTreasury = await blockchain.treasury('rich', { 
    balance: toNano(10_000_000n)
});

// Use treasury sender for transactions
await contract.sendMessage(treasury.getSender(), toNano('1'), messageBody);

// Treasury handles all operations automatically
```

### `RemoteBlockchainStorage`

Storage implementation that fetches contract states from a real TON network.

```typescript
class RemoteBlockchainStorage implements BlockchainStorage {
    constructor(client: TonClient4Wrapper, blockSeqno?: number)
}
```

**Parameters:**
- `client` — wrapped TON client for network access
- `blockSeqno` — optional block number to fetch state from

**Usage example:**
```typescript
import { TonClient4 } from '@ton/ton';
import { RemoteBlockchainStorage, wrapTonClient4ForRemote } from '@ton/sandbox';

const blockchain = await Blockchain.create({
    storage: new RemoteBlockchainStorage(
        wrapTonClient4ForRemote(
            new TonClient4({
                endpoint: 'https://mainnet-v4.tonhubapi.com'
            })
        )
    )
});
```

## Type Definitions

### `SandboxContract`

Enhanced contract wrapper that transforms contract methods for sandbox testing. SandboxContract automatically wraps `get` methods and `send` methods to work with the sandbox environment.

```typescript
export type SandboxContract<F> = {
    [P in keyof F]: P extends `${'get' | 'is'}${string}`
        ? F[P] extends (x: infer CP, ...args: infer P) => infer R
            ? ExtendsContractProvider<CP> extends true
                ? (...args: P) => R
                : never
            : never
        : P extends `send${string}`
            ? F[P] extends (x: infer CP, ...args: infer P) => infer R
                ? ExtendsContractProvider<CP> extends true
                    ? (...args: P) => Promise<SendMessageResult & {
                        result: R extends Promise<infer PR> ? PR : R;
                    }>
                    : never
                : never
            : F[P];
};
```

**Key transformations:**
- **Get methods** (`get*`) — Remove the ContractProvider parameter, return the same result
- **Send methods** (`send*`) — Remove ContractProvider parameter, return `Promise<SendMessageResult & { result: R }>`
- **Other properties** — Remain unchanged

**Usage example:**
```typescript
// Open a contract in sandbox
const myContract = blockchain.openContract(MyContract.createFromConfig(config, code));

// Deploy the contract - returns SendMessageResult
const deployResult = await myContract.sendDeploy(deployer.getSender(), toNano('0.05'));
expect(deployResult.transactions).toHaveTransaction({
    from: deployer.address,
    to: myContract.address,
    success: true
});

// Send methods return SendMessageResult with transaction info
const incrementResult = await myContract.sendIncrement(user.getSender(), toNano('0.1'));
expect(incrementResult.transactions).toHaveTransaction({
    from: user.address,
    to: myContract.address,
    success: true
});

// Get methods work the same as production
const counter = await myContract.getCounter();
expect(counter).toBe(1n);
```


### `SendMessageResult`

Result of sending a message to the blockchain emulator.

```typescript
export type SendMessageResult = {
    transactions: BlockchainTransaction[];
    events: Event[];
    externals: ExternalOut[];
};
```

**Properties:**
- `transactions` — array of blockchain transactions that resulted from the message
- `events` — array of blockchain events emitted during execution
- `externals` — array of external messages generated during execution

### `BlockchainTransaction`

Enhanced transaction type with additional sandbox-specific properties.

```typescript
export type BlockchainTransaction = SmartContractTransaction & {
    events: Event[];
    parent?: BlockchainTransaction;
    children: BlockchainTransaction[];
    externals: ExternalOut[];
    mode?: number;
};
```

**Properties:**
- `events` — blockchain events emitted during transaction execution
- `parent` — parent transaction that triggered this one
- `children` — child transactions triggered by this transaction
- `externals` — external messages generated during execution
- `mode` — transaction execution mode

### `MessageParams`

Optional parameters for message sending operations.

```typescript
export type MessageParams = Partial<{
    now: number;
    randomSeed: Buffer;
    ignoreChksig: boolean;
}>;
```

**Properties:**
- `now` — override blockchain time for this message (UNIX timestamp)
- `randomSeed` — random seed for deterministic execution
- `ignoreChksig` — whether `CHKSIG` instructions are set to always succeed

### `GetMethodParams`

Optional parameters for get method execution.

```typescript
export type GetMethodParams = Partial<{
    now: number;
    randomSeed: Buffer;
    gasLimit: bigint;
}>;
```

**Properties:**
- `now` — override blockchain time for this call (UNIX timestamp)
- `randomSeed` — random seed for deterministic execution
- `gasLimit` — override TVM emulator gas limit (default: 10,000,000)

### `GetMethodResult`

Result of executing a get method on a contract.

```typescript
export type GetMethodResult = {
    stack: TupleItem[];
    stackReader: TupleReader;
    exitCode: number;
    gasUsed: bigint;
    blockchainLogs: string;
    vmLogs: string;
    debugLogs: string;
};
```

**Properties:**
- `stack` — raw stack items returned by the method
- `stackReader` — convenient reader for parsing stack items
- `exitCode` — TVM exit code (0 for success)
- `gasUsed` — amount of gas consumed during execution
- `blockchainLogs` — blockchain-level execution logs
- `vmLogs` — TVM execution logs
- `debugLogs` — debug-level execution logs
### `Verbosity`

Verbosity levels for TVM execution logging.

```typescript
export type Verbosity = 'none' | 'vm_logs' | 'vm_logs_location' | 'vm_logs_gas' | 'vm_logs_full' | 'vm_logs_verbose';
```

**Values:**
- `'none'` — no VM logs
- `'vm_logs'` — basic VM execution logs
- `'vm_logs_location'` — VM logs with code location information
- `'vm_logs_gas'` — VM logs with gas consumption details
- `'vm_logs_full'` — comprehensive VM logs
- `'vm_logs_verbose'` — maximum verbosity VM logs
### `LogsVerbosity`

Configuration for different types of logging output.

```typescript
export type LogsVerbosity = {
    print: boolean;
    blockchainLogs: boolean;
    vmLogs: Verbosity;
    debugLogs: boolean;
};
```

**Properties:**
- `print` — enable console output
- `blockchainLogs` — enable blockchain-level logs
- `vmLogs` — TVM execution verbosity level
- `debugLogs` — enable debug-level logs
### `SmartContractTransaction`

Enhanced transaction type with execution logs and storage information.

```typescript
export type SmartContractTransaction = Transaction & {
    blockchainLogs: string;
    vmLogs: string;
    debugLogs: string;
    oldStorage?: Cell;
    newStorage?: Cell;
    outActions?: OutAction[];
};
```

**Properties:**
- `blockchainLogs` — blockchain execution logs
- `vmLogs` — TVM execution logs
- `debugLogs` — debug execution logs
- `oldStorage` — contract storage before transaction (if `recordStorage` enabled)
- `newStorage` — contract storage after transaction (if `recordStorage` enabled)
- `outActions` — output actions generated during execution

### `BlockchainSnapshot`

Snapshot of blockchain state for persistence and restoration.

```typescript
export type BlockchainSnapshot = {
    contracts: SmartContractSnapshot[];
    networkConfig: string;
    lt: bigint;
    time?: number;
    verbosity: LogsVerbosity;
    libs?: Cell;
    nextCreateWalletIndex: number;
    prevBlocksInfo?: PrevBlocksInfo;
    randomSeed?: Buffer;
    autoDeployLibs: boolean;
    transactions: BlockchainTransaction[];
};
```

**Properties:**
- `contracts` — snapshots of all contract states
- `networkConfig` — blockchain configuration
- `lt` — current logical time
- `time` — current blockchain time
- `verbosity` — logging configuration
- `libs` — shared libraries
- `nextCreateWalletIndex` — next treasury wallet index
- `prevBlocksInfo` — previous blocks information
- `randomSeed` — random seed for execution
- `autoDeployLibs` — auto-deploy libraries flag
- `transactions` — transaction history

### `GetMethodResultSuccess`

Successful get method execution result from remote API.

```typescript
export type GetMethodResultSuccess = {
    success: true;
    stack: string;
    gas_used: string;
    vm_exit_code: number;
    vm_log: string;
    missing_library: string | null;
};
```

**Properties:**
- `success` — always true for successful results
- `stack` — serialized result stack
- `gas_used` — gas consumption as string
- `vm_exit_code` — TVM exit code
- `vm_log` — TVM execution log
- `missing_library` — missing library hash if any

### `GetMethodResultError`

Failed get method execution result from remote API.

```typescript
export type GetMethodResultError = {
    success: false;
    error: string;
};
```

**Properties:**
- `success` — always false for error results
- `error` — error description

### `Event` Types

Blockchain events emitted during transaction execution.

```typescript
export type EventAccountCreated = {
    type: 'account_created';
    account: Address;
};

export type EventAccountDestroyed = {
    type: 'account_destroyed';
    account: Address;
};

export type EventMessageSent = {
    type: 'message_sent';
    from: Address;
    to: Address;
    value: bigint;
    body: Cell;
    bounced: boolean;
};

export type Event = EventAccountCreated | EventAccountDestroyed | EventMessageSent;
```

**Event Types:**
- `EventAccountCreated` — account was created during execution
- `EventAccountDestroyed` — account was destroyed during execution  
- `EventMessageSent` — message was sent during execution

### `BlockId`

Identifier for a blockchain block.

```typescript
export type BlockId = {
    workchain: number;
    shard: bigint;
    seqno: number;
    rootHash: Buffer;
    fileHash: Buffer;
};
```

**Properties:**
- `workchain` — workchain number
- `shard` — shard identifier
- `seqno` — sequence number
- `rootHash` — block root hash
- `fileHash` — block file hash

### `PrevBlocksInfo`

Information about previous blocks in the blockchain.

```typescript
export type PrevBlocksInfo = {
    lastMcBlocks: BlockId[];
    prevKeyBlock: BlockId;
    lastMcBlocks100?: BlockId[];
};
```

**Properties:**
- `lastMcBlocks` — last masterchain blocks
- `prevKeyBlock` — previous key block
- `lastMcBlocks100` — last 100 masterchain blocks (optional)

### `SerializableSnapshot`

JSON-serializable format for blockchain snapshots.

```typescript
export type SerializableSnapshot = {
    contracts: {
        address: string;
        account: string;
        lastTxTime: number;
        verbosity?: Partial<LogsVerbosity>;
    }[];
    networkConfig: string;
    lt: string;
    time?: number;
    verbosity: LogsVerbosity;
    libs?: string;
    nextCreateWalletIndex: number;
    prevBlocksInfo?: {
        lastMcBlocks: SerializableBlockId[];
        prevKeyBlock: SerializableBlockId;
        lastMcBlocks100?: SerializableBlockId[];
    };
    randomSeed?: string;
    autoDeployLibs: boolean;
    transactions: {
        transaction: string;
        blockchainLogs: string;
        vmLogs: string;
        debugLogs: string;
        oldStorage?: string;
        newStorage?: string;
        outActions?: string;
        externals: string[];
        mode?: number;
        parentHash?: string;
        childrenHashes: string[];
    }[];
};
```

### `ExtraCurrency`

Type for extra currencies in transactions.

```typescript
export type ExtraCurrency = {
    [key: number]: bigint;
};
```

**Properties:**
- `[key: number]` — currency ID mapped to amount in basic units

## Utility functions

### `loadConfig()`

Loads and parses blockchain configuration from Cell or base64 string.

```typescript
export function loadConfig(configCellOrBase64: string | Cell): BlockchainConfig;
```

**Parameters:**
- `configCellOrBase64` — configuration as Cell or base64 string

**Returns:** parsed BlockchainConfig object

### `updateConfig()`

Updates blockchain configuration with new parameters.

```typescript
export function updateConfig(config: Cell, ...params: ConfigParam[]): Cell;
```

**Parameters:**
- `config` — existing configuration Cell
- `...params` — configuration parameters to update

**Returns:** updated configuration Cell

### `prettyLogTransaction()`

Creates a formatted log string for a transaction.

```typescript
export function prettyLogTransaction(tx: Transaction, mapFunc?: AddressMapFunc): string;
```

**Parameters:**
- `tx` — transaction to create log string for
- `mapFunc` — optional function to map addresses to human-readable strings

**Returns:** formatted transaction log string

### `prettyLogTransactions()`

Logs multiple transactions to console using formatted output.

```typescript
export function prettyLogTransactions(txs: Transaction[], mapFunc?: AddressMapFunc): void;
```

**Parameters:**
- `txs` — transactions to log
- `mapFunc` — optional function to map addresses to human-readable format

**Example Output:**
```
null  ➡️  EQBGhqLAZseEqRXz4ByFPTGV7SVMlI4hrbs-Sps_Xzx01x8G
      ➡️  0.05 💎 EQC2VluVfpj2FoHNMAiDMpcMzwvjLZxxTG8ecq477RE3NvVt
```

### `internal()` (Utility Function)

Creates an internal message from parameters. This is a utility function used internally and in message builders.

```typescript
export function internal(params: {
    from: Address;
    to: Address;
    value: bigint;
    body?: Cell;
    stateInit?: StateInit;
    bounce?: boolean;
    bounced?: boolean;
    ihrDisabled?: boolean;
    ihrFee?: bigint;
    forwardFee?: bigint;
    createdAt?: number;
    createdLt?: bigint;
    ec?: Dictionary<number, bigint> | [number, bigint][] | ExtraCurrency;
}): Message;
```
TODO: describe more, and usage
**Parameters:**
- `from` — sender address
- `to` — recipient address
- `value` — message value in nanoTON
- `body` — message body cell
- `bounce` — bounce flag (default: true)

**Usage example:**
```typescript
const message = internal({
    from: sender.address,
    to: contract.address,
    value: toNano('1'),
    body: beginCell().storeUint(1, 32).endCell()
});
```

### `printTransactionFees()`

Prints transaction fees in a formatted table to console.

```typescript
export function printTransactionFees(transactions: Transaction[], mapFunc?: OpMapFunc): void;
```

**Parameters:**
- `transactions` — list of transactions to analyze and print fees for
- `mapFunc` — optional function to map operation codes to human-readable format

**Returns:** `void` (outputs formatted table to console)

### `snapshotToSerializable()`

```typescript
export function snapshotToSerializable(snapshot: BlockchainSnapshot): SerializableSnapshot;
```

**Parameters:**
- `snapshot` — blockchain snapshot to serialize

**Returns:** `SerializableSnapshot` — JSON-serializable snapshot object

### `snapshotFromSerializable()`

```typescript
export function snapshotFromSerializable(serialized: SerializableSnapshot): BlockchainSnapshot;
```

**Parameters:**
- `serialized` — serialized snapshot object

**Returns:** `BlockchainSnapshot` — restored blockchain snapshot

**Usage example:**
```typescript
import { snapshotToSerializable, snapshotFromSerializable } from '@ton/sandbox';
import fs from 'fs';

// Save snapshot to file
const snapshot = blockchain.snapshot();
const serializable = snapshotToSerializable(snapshot);
fs.writeFileSync('snapshot.json', JSON.stringify(serializable));

// Load snapshot from file
const loaded = JSON.parse(fs.readFileSync('snapshot.json', 'utf8'));
const restored = snapshotFromSerializable(loaded);
await blockchain.loadFrom(restored);
```

### `setGlobalVersion()`

Sets global version in blockchain configuration.

```typescript
export function setGlobalVersion(config: Cell, version: number, capabilites?: bigint): Cell;
```

**Parameters:**
- `config` — blockchain configuration Cell
- `version` — global version number to set
- `capabilites` — optional capabilities flags

**Returns:** `Cell` — updated configuration Cell

### `fetchConfig()`

Fetches blockchain configuration from TON network.

```typescript
export async function fetchConfig(network: 'mainnet' | 'testnet', maxRetries?: number): Promise<Cell>;
```

**Parameters:**
- `network` — network to fetch config from (`'mainnet'` or `'testnet'`)
- `maxRetries` — maximum number of retry attempts (default: 5)

**Returns:** `Promise<Cell>` — blockchain configuration Cell

### `registerCompiledContract()`

Registers compiled contract for debugging support.

```typescript
export function registerCompiledContract(code: Cell, debugInfo: FuncDebugInfo, marks: Cell): Cell;
```

**Parameters:**
- `code` — compiled contract code Cell
- `debugInfo` — FuncC debug information
- `marks` — debug marks Cell

**Returns:** `Cell` — the same code Cell (for chaining)

## Test matchers

Test matchers for testing TON blockchain transactions and state. Import from `@ton/test-utils` to use these matchers.

```typescript
import '@ton/test-utils';
```

TODO: describe all test matchers in a way before (H4 for matchers)
```

export type ExtendedTransaction = Transaction & {
    mode?: number;
};

export type FlatTransaction = {
    from?: Address;
    to?: Address;
    on?: Address;
    value?: bigint;
    ec?: [number, bigint][];
    body?: Cell;
    inMessageBounced?: boolean;
    inMessageBounceable?: boolean;
    op?: number;
    initData?: Cell;
    initCode?: Cell;
    deploy: boolean;
    lt: bigint;
    now: number;
    outMessagesCount: number;
    oldStatus: AccountStatus;
    endStatus: AccountStatus;
    totalFees?: bigint;
    aborted?: boolean;
    destroyed?: boolean;
    exitCode?: number;
    actionResultCode?: number;
    success?: boolean;
    mode?: number;
};

declare global {
    // eslint-disable-next-line @typescript-eslint/no-namespace
    export namespace jest {
        interface Matchers<R> {
            toHaveTransaction(cmp: FlatTransactionComparable): R;
            toEqualCell(cell: Cell): R;
            toEqualAddress(address: Address): R;
            toEqualSlice(slice: Slice): R;

            /**
             * @example
             * await expect(() => blockchain.runGetMethod(contract.address, 'test')).toThrowExitCode(11);
             */
            toThrowExitCode(exitCode: number): Promise<R>;
        }
    }
}
```

## Network configuration

### Custom network configuration

```typescript
import { loadConfig, updateConfig } from '@ton/sandbox';

const oldConfig = loadConfig(blockchain.config);
const updatedConfig = updateConfig(oldConfig, {
    ...oldConfig[8],
    anon0: {
        ...oldConfig[8].anon0,
        version: 99,
    },
});
blockchain.setConfig(updatedConfig);
```
