---
title: "Sending messages"
---
## Overview

To send messages to contracts, use the `.send()` method on their TypeScript wrappers like so:

```tact
// It accepts 3 arguments:
await yourContractName.send(
  // 1. sender of the message
  deployer.getSender(), // this is a default treasury, can be replaced

  // 2. value and (optional) bounce, which is true by default
  { value: toNano('0.5'), bounce: false },

  // 3. a message body, if any
  'Look at me!',
);
```

The message body can be a simple string or an object specifying fields of the Message type:

```tact
await yourContractName.send(
  deployer.getSender(),
  { value: toNano('0.5') },
  {
    $$type: 'NameOfYourMessageType',
    field1: 0n, // bigint zero
    field2: 'yay',
  },
);
```

More often than not, it’s important to store the results of such sends because they contain events that occurred, transactions made, and external messages sent:

```tact
const res = await yourContractName.send(…);
// res.events — array of events occurred
// res.externals — array of external-out messages
// res.transactions — array of transactions made
```

With that, we can easily filter or check certain transactions:

```tact
expect(res.transactions).toHaveTransaction(…);
```

### Observe the fees and values

Sandbox provides a helper function printTransactionFees(), which pretty-prints all the values and fees used in the provided transactions. It is quite handy for observing the flow of nanoToncoins.

To use it, modify the imports from `@ton/sandbox` at the top of the test file:

```tact
import { Blockchain, SandboxContract, TreasuryContract, printTransactionFees } from '@ton/sandbox';
//                                                      ^^^^^^^^^^^^^^^^^^^^
```
Then, provide an array of transactions as an argument, like so:

```tact
printTransactionFees(res.transactions);
```

To work with individual values of total fees or fees from the compute and action phases, inspect each transaction individually:

```tact
// Storing the transaction handled by the receiver in a separate constant
const receiverHandledTx = res.transactions[1];
expect(receiverHandledTx.description.type).toEqual('generic');

// Needed to please TypeScript
if (receiverHandledTx.description.type !== 'generic') {
  throw new Error('Generic transaction expected');
}

// Total fees
console.log('Total fees: ', receiverHandledTx.totalFees);

// Compute fee
const computeFee = receiverHandledTx.description.computePhase.type === 'vm'
  ? receiverHandledTx.description.computePhase.gasFees
  : undefined;
console.log('Compute fee: ', computeFee);

// Action fee
const actionFee = receiverHandledTx.description.actionPhase?.totalActionFees;
console.log('Action fee: ', actionFee);

// Now we can do some involved checks, like limiting the fees to 1 Toncoin
expect(
  (computeFee ?? 0n)
  + (actionFee ?? 0n)
).toBeLessThanOrEqual(toNano('1'));
```


### Transactions with intentional errors

Sometimes it’s useful to perform negative tests featuring intentional errors and throwing specific exit codes.

An example of such a Jest test closure in Blueprint:

```tact title="tests/YourTestFileHere.spec.ts"
it('throws specific exit code', async () => {
  // Send a specific message to our contract and store the result
  const res = await your_contract_name.send(
    deployer.getSender(),
    {
      value: toNano('0.5'), // value in nanoToncoins sent
      bounce: true,         // (default) bounceable message
    },
    'the message your receiver expects', // ← change it to yours
  );

  // Expect the transaction to our contract to fail with a certain exit code
  expect(res.transactions).toHaveTransaction({
    to: your_contract_name.address,
    exitCode: 5, // ← change it to yours
  });
});
```

Note that to track down transactions with a certain exit code, you only need to specify the exitCode field in the object argument to the `toHaveTransaction()` method of `expect()`.

However, it’s useful to narrow the scope by specifying the recipient address to, so that Jest looks only at the transaction caused by our message to the contract.

### Simulate passage of time

The Unix time in local blockchain instances provided by Sandbox starts at the moment of their creation in the `beforeEach()` block.

```tact
beforeEach(async () => {
  blockchain = await Blockchain.create(); // ← here
  // ...
});
```

Previously, we’ve been warned not to modify the beforeEach() block unless we really need to. Now, we must override the time and travel a little forward.

Let’s add the following line at the end of it, explicitly setting blockchain.now to the time when the deployment message was handled:

```tact
beforeEach(async () => {
  // ...
  blockchain.now = deployResult.transactions[1].now;
});
```

Now, we can manipulate time in our test clauses. For example, let’s make a transaction one minute after deployment and another one after two minutes:

```tact
it('your test clause title', async () => {
  blockchain.now += 60; // 60 seconds later
  const res1 = await yourContractName.send(…);
  blockchain.now += 60; // another 60 seconds later
  const res2 = await yourContractName.send(…);
});
```

## Logging via `emit`

A global function `emit()` sends a message to the outer world — it doesn’t have a specific recipient.

This function is very handy for logging and analyzing data off-chain — one just has to look at external messages produced by the contract.

### Logs in local Sandbox tests

When deploying in the Sandbox, you may call `emit()` from a receiver function and then observe the list of sent external messages:

```tact
it('emits', async () => {
  const res = await simpleCounter.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'emit_receiver', // ← change to the message your receiver handles
  );

  console.log("Address of our contract: " + simpleCounter.address);
  console.log(res.externals); // ← here you would see results of emit() calls,
                              //   and all external messages in general
});
```

### Logs of a deployed contract

Every transaction on TON Blockchain contains `out_msgs` — a dictionary that holds the list of outgoing messages created during the transaction execution.

To see logs from `emit()` in that dictionary, look for external messages without a recipient. In various TON Blockchain explorers, such transactions will be marked as external-out with the destination specified as - or empty.

Note that some explorers deserialize the message body sent for you, while others don’t. However, you can always parse it yourself locally.

### Parsing the body of the emitted message
Consider the following example:

```tact
// We have a struct
struct Ballroom {
    meme: Bool;
    in: Int;
    theory: String;
}

// And a simple contract,
contract Bonanza {
    // which can receive a String message,
    receive("time to emit") {
        // emit a String
        emit("But to the Supes? Absolutely diabolical.".asComment());

        // and a struct
        emit(Ballroom { meme: true, in: 42, theory: "Duh" }.toCell());
    }
}
```

Now, let’s make a simple test clause for the Bonanza contract:

```tact
it('emits', async () => {
  const res = await bonanza.send(
    deployer.getSender(),
    { value: toNano('0.05') },
    'time to emit',
  );
});
```

Here, the `res` object would contain the list of sent external messages as its externals field. Let’s access it to parse the first message sent via a call to `emit()` in Tact code (or emitted for short):

```tact
it('emits', async () => {
  // ... prior code ...

  // We'll need only the body of the observed message:
  const firstMsgBody = res.externals[0].body;

  // Now, let's parse it, knowing it's a text message.
  // NOTE: In a real-world scenario,
  //       you'd want to check that first or wrap this in a try...catch
  const firstMsgText = firstMsgBody.asSlice().loadStringTail();

  // "But to the Supes? Absolutely diabolical."
  console.log(firstMsgText);
});
```

To parse the second emitted message, we could manually use various `Slice` extension functions, but that’s overly brittle — if the fields of the `Ballroom` struct ever change, you’d need to start all over. That could significantly backfire when you have numerous tests written in that manner.

Fortunately, the Tact compiler auto-generates TypeScript bindings (or wrappers) for contracts, making it easy to reuse them in your test suite. Not only do they provide wrappers for the contract you’re testing, but they also export helper functions to store or load structs and Messages defined in the contract. These helper functions have names similar to their corresponding structures, prefixed with `load`.

For example, in our case, we’ll need a function called `loadBallroom()`, to parse a `Slice` into the `Ballroom` struct in TypeScript. To import it, either type the name and let your IDE suggest auto-importing it for you, or look at the top of your test suite file — there should be a similar line:

```tact
import { Bonanza } from '../wrappers/Bonanza';
//              ^ here you could import loadBallroom
```

With that, let’s parse the second emitted message:

```tact
it('emits', async () => {
  // ... prior code ...

  // We'll need only the body of the observed message:
  const secondMsgBody = res.externals[1].body;

  // Now, let's parse it, knowing it's the Ballroom struct.
  // NOTE: In a real-world scenario,
  //       you'd want to check that first or wrap this in a try...catch
  const secondMsgStruct = loadBallroom(secondMsgBody.asSlice());

  // { '$$type': 'Ballroom', meme: true, in: 42n, theory: 'Duh' }
  console.log(secondMsgStruct);
});
```

Note that it’s also possible to parse emitted messages of deployed contracts outside of our test suite. You would simply need to obtain the emitted message bodies and use the auto-generated TypeScript bindings from Tact alongside the `@ton/core` library, just like we’ve done in the examples above.

## Handling bounced messages

When sent with `bounce: true`, messages can bounce back in case of errors. Make sure to write the relevant `bounced()` message receivers and handle bounced messages gracefully:

```tact
bounced(msg: YourMessage) {
// ...alright squad, let's bounce!...
}
```

Keep in mind that bounced messages in TON have only 224 usable data bits in their message body and do not have any references, so one cannot recover much data from them. However, you still get to see whether the message has bounced or not, allowing you to create more robust contracts.

Read more about bounced messages and receivers: Bounced messages.