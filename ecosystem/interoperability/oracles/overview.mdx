---
title: "Oracles overview"
sidebarTitle: "Overview"
---

import { Aside } from '/snippets/aside.jsx';

Blockchain oracles are entities that connect the blockchain to external systems, allowing smart contracts to be executed based on real-world inputs.

## Blockchain oracle fundamentals

Blockchain oracles are specialized services that act as bridges between the real world and blockchain technology. They provide smart contracts with relevant and necessary information from the outside world, such as exchange rates, payment statuses, or even weather conditions. This data helps to automate and fulfill the terms of contracts without direct human intervention.

The basic principle behind oracles is their ability to function outside of the blockchain by connecting to various online sources to collect data. Although oracles are not part of the blockchain itself, they play a key role in making it functional by acting as a trusted intermediary that reliably feeds external data into the system.

Most oracles are decentralized, avoiding the risks associated with dependence on a single source of data. This provides greater security and reliability to the system as data is verified and validated through a network of nodes before it is used in smart contracts. This approach minimizes the risk of manipulation and errors, ensuring that the information provided is accurate and up-to-date.

## Varieties of blockchain oracles

Blockchain oracles are categorized according to various aspects: mechanism of operation, data sources, data direction, and governance structure. Common types of oracles include:

### Push and pull oracles

Push and pull oracles differ in how they deliver data to an on-chain smart contract.

For a push oracle, the data provider constantly updates information, pushing the newest data to a centralized trusted contract.

Read more about oracle model differences: [Chainlink â€” Pull vs. push oracles](https://chain.link/education-hub/pull-oracles-vs-push-oracles).

For a pull oracle, users retrieve the latest data from the off-chain data provider, then verify it using the oracle contract. [Oracles in TON](#oracles-in-ton) describes the data verification flow with pull-model oracles.

Given The Open Network (TON) actor model, pull oracles prove to be more suited for real-world applications.

### Centralized and decentralized oracles

Centralized oracles are controlled by a single party, which creates security and reliability risks. Decentralized oracles use multiple nodes to verify data, making them more secure and reliable.

### Cross-chain oracles

These oracles are used to transfer data between different blockchains and are a critical component of bridges. They are used for decentralized applications that use cross-chain transactions, such as cross-chain transfer of crypto assets from one network to another.

## Application of blockchain oracles

Blockchain oracles build bridges between the digital world of blockchains and real life, opening up a wide range of applications. Common oracle use cases include:

### Decentralized finance (DeFi)

Oracles play a critical role in the DeFi ecosystem by providing market price and cryptocurrency data. Price oracles allow DeFi platforms to link token values to real assets, which is essential for controlling liquidity and securing users' positions. Additionally, oracles are vital for lending platforms, where accurate price data ensures proper collateral valuation and risk management, safeguarding both lenders and borrowers. This makes transactions more transparent and secure, contributing to the stability and reliability of financial transactions.

### Prediction markets

Oracles can automatically read and analyze data from a variety of sources to determine the occurrence of real-life events. This allows prediction and insurance contracts to pay claims automatically, reducing the need to manually process each case and speeding up response times to events.

### Random number generation

It is difficult to generate random numbers in smart contracts because all operations must be reproducible and predictable, which contradicts the concept of randomness. Computational oracles solve this problem by bringing data from the outside world into contracts. They can generate verifiable random numbers for games and lotteries, ensuring fairness and transparency of results.

Read more: [Randomness in TON](/techniques/random)

## Oracles in TON

Since the TON execution model is asynchronous, the classic ways to interact with oracles (get methods during a transaction) can't be applied here. You can learn about differences in [Coming from Ethereum](/guidebook/from-ethereum). The pattern to get data from an oracle that works the best is the [Carry-value pattern](/techniques/carry-value). You send an internal message to the oracle contract and verify the response, getting the needed data.

This model works well with pull oracles, since you can always guarantee the lowest possible latency for real-world data. If you use a push oracle, you will still need to process two internal messages (request and response) to retrieve data. However, data relevance is limited by the data provider uptime and pushing intervals: if the data provider pushes updated data every 10 minutes, you will commonly receive information that is outdated by 5 minutes. By using a pull oracle, you can ensure pushes as often as your service needs by updating the data yourself.

### Push oracle flow

1. The data provider pushes the latest data on-chain.

1. The user contract that needs on-chain prices sends a request message to the trusted oracle contract.

1. The oracle contract replies to the sender address with an internal response message containing the requested data.

1. The user contract receives the oracle response, verifies the sender address, and is then ready to use the provided data.

### Pull oracle flow

1. The user's off-chain backend calls an API method on the data provider.

1. The provider responds with signed price data (including the timestamp until this data is valid).

1. The user sends a message to their on-chain contract.

1. The on-chain contract needs prices (and the rest of the business logic).

1. The user contract sends an internal message to the oracle contract to verify that the price is correctly signed and valid.

1. The oracle contract verifies the signature, timestamp, and price feed ID; if everything is okay, it sends a response with prices back.

1. The user contract receives the response from the oracle contract, checks that the sender is the oracle, and then can use the provided data.


![Oracle flow diagram](/resources/images/oracles/oracle-flow.svg)



## List of oracles in TON

- [RedStone](/ecosystem/interoperability/oracles/redstone)
- [Pyth](/ecosystem/interoperability/oracles/pyth)
