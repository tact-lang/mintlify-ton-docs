---
title: "How TON wallets work"
sidebarTitle: "How they work"
---

import { Aside } from '/snippets/aside.jsx';

Wallets are often the entry point of any transaction flow in TON (TODO: link to external messages).

General principle:
A wallet smart contract stores two critical variables — the public key and the sequence number (`seqno`). Together they secure the wallet.

Using the public key, the contract can verify that the request really comes from the wallet owner; and using `seqno`, it protects against replayed transactions (details below).

## How ownership verification works

We use the Ed25519 algorithm.
You generate a private key (keep it safe) and a public key (stored in the contract; readable by anyone).

<Aside type="caution" title="Important">
The public key is NOT the wallet address. The address is derived from the contract's StateInit and other parameters. (TODO: link to TON address formats)
</Aside>

An external message is sent to the contract (containing a 512‑bit signature and the desired payload). Ed25519 verifies that the provided signature matches the hash of the message.

## How replay protection works

<Aside type="note" title="Why do we need replay protection?">
Imagine Alice has 100 TON. Alice sends 10 TON to Bob as a gift. Bob, being sneaky, forwards the exact same message to Alice's wallet and would receive another 10 TON — unless the wallet prevents replays.
</Aside>

Each transaction carries a counter value (in our case, `seqno`) that must be unique and strictly increasing for every outgoing transaction. Because `seqno` changes, the message hash changes as well, making it impossible to reuse a previous signature.