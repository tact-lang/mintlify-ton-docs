---
title: "Wallet V5 API"
sidebarTitle: "How to interact"
---

This article provides overview of wallet V5 public interfaces, how to interact with them and serialize used data structures.

There are several ways how you can interact with deployed V5 wallet smart contract:

- Send external signed message
- Send internal signed message
- Send internal message from extension
- Call get-methods

Let's first explore message structure, that is used to perform different actions on wallet contract.

## Message structure

Message structure for V5 wallet contract is quite cumbersome and hard to read, it's made for optimal (de-)serialization and not optimized for understanding. It is described in [TL-B](/language/TL-B/overview) language and includes snake-cell pattern. We will try to get a grip of it by breaking down core data structures and how they are used.

You can skip to [Examples section](#examples), where we would use existing high-level libraries that abstract low level logic from the user.

### TL-B

This is TL-B for V5 wallet actions, it includes some [complex TL-B patterns](/language/TL-B/complex-and-non-trivial-examples.mdx). You can also find it on [GitHib](https://github.com/ton-blockchain/wallet-contract-v5/blob/321186127e8cc5e395ad3b2f1870839237c56f5f/types.tlb), in the wallet repo.

```tlb expandable
// Standard actions from block.tlb:
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction = OutList (n + 1);
action_send_msg#0ec3c86d mode:(## 8) out_msg:^(MessageRelaxed Any) = OutAction;

// Extended actions in W5:
action_list_basic$_ {n:#} actions:^(OutList n) = ActionList n 0;
action_list_extended$_ {m:#} {n:#} action:ExtendedAction prev:^(ActionList n m) = ActionList n (m+1);

action_add_ext#02 addr:MsgAddressInt = ExtendedAction;
action_delete_ext#03 addr:MsgAddressInt = ExtendedAction;
action_set_signature_auth_allowed#04 allowed:(## 1) = ExtendedAction;

signed_request$_             // 32 (opcode from outer)
  wallet_id:    #            // 32
  valid_until:  #            // 32
  msg_seqno:    #            // 32
  inner:        InnerRequest //
  signature:    bits512      // 512
= SignedRequest;             // Total: 688 .. 976 + ^Cell

internal_signed#73696e74 signed:SignedRequest = InternalMsgBody;
internal_extension#6578746e query_id:(## 64) inner:InnerRequest = InternalMsgBody;
external_signed#7369676e signed:SignedRequest = ExternalMsgBody;

actions$_ out_actions:(Maybe OutList) has_other_actions:(## 1) {m:#} {n:#} other_actions:(ActionList n m) = InnerRequest;

// Contract state
contract_state$_ is_signature_allowed:(## 1) seqno:# wallet_id:(## 32) public_key:(## 256) extensions_dict:(HashmapE 256 int1) = ContractState;
```

Three types of messages that were described above can be seen here:

```tlb
internal_signed#73696e74 signed:SignedRequest = InternalMsgBody;
internal_extension#6578746e query_id:(## 64) inner:InnerRequest = InternalMsgBody;
external_signed#7369676e signed:SignedRequest = ExternalMsgBody;
```

Each of them includes the same `InnerRequest` field that dictates whats need to be done by wallet contract. In case of signed messages, the request needs to be verified, so `InnerRequest` is wrapped in `SignedRequest` structure, which contains necessary information for this.

Let's break down these data structures.

### Signed Request

Signed message is a message that was signed using owners private key from his dedicated keypair, method from asymmetric cryptography. Later this message will be verified on-chain using public key stored in wallet smart contract - [read more](/standard/wallets/how-it-works#how-ownership-verification-works) about how ownership verification works.

Before V5 standard, there was only one way to deliver signed message to wallet contract - via external-in message. However, external messages has certain limitations, e.g. you can only send external-out messages from the smart contracts themselves. This means that it wasn't possible to deliver signed message from inside the blockchain, from another smart contract. V5 standard adds this functionality, partially enabling [gassless transaction](/standard/wallets/v5#preparing-for-gasless-transactions).

Besides `InnerRequest` field that contains actual actions that will be performed, `Signed message` structure contains usual wallet message fields that were in-place in previous versions, read more about them [here](/standard/wallets/how-it-works).

### Inner Request

Inner request is defined as follows:

```tlb
actions$_ out_actions:(Maybe OutList) has_other_actions:(## 1) {m:#} {n:#} other_actions:(ActionList n m) = InnerRequest;
```

V5 wallet supports two main types of actions that can be performed:

```mermaid
graph TD
    A[Root Actions] --> B[Send Message Action]
    A --> C[Extended Actions]
    C --> D[Add Extension]
    C --> E[Delete Extension]
    C --> F[Set Signature Auth]
```

The action structure allows for:
- **Send Message Actions**: Standard message sending with specified mode
- **Extended Actions**: Advanced wallet management operations
  - **Add Extension**: Register new extension addresses
  - **Delete Extension**: Remove extension addresses
  - **Set Signature Auth**: Enable/disable signature-based authentication

As you can see in TL-B, `out_actions` are snake-cell list of ordinary out messages, followed then by binary flag `has_other_actions` and `other_actions` extended action list.

#### Inner Request Structure

The Inner Request serialization follows this structure:

```mermaid
graph TD
    A[Inner Request] --> B[out_actions: Maybe OutList]
    A --> C[has_other_actions: 1 bit]

    B --> B1{Has out actions?}
    B1 -->|Yes| B2[OutList Chain]
    B1 -->|No| B3[Empty/Nothing]

    B2 --> B4[Mode: 8 bits]
    B2 --> B5[Message Reference]
    B2 --> B6[Previous OutList Reference]

    C --> C1{Bit = 1?}
    C1 -->|Yes| D[other_actions: ActionList]
    C1 -->|No| D1[No extended actions]

    D --> D2[Extended Action]
    D --> D3[Previous ActionList Reference]

    D2 --> D4[Add Extension #02]
    D2 --> D5[Delete Extension #03]
    D2 --> D6[Set Signature Auth #04]

    style A fill:#e1f5fe
    style B2 fill:#f3e5f5
    style D fill:#e8f5e8
```

#### Serialization Layout

The Inner Request is serialized in the following order:

```mermaid
graph LR
    subgraph "Cell Data"
        A[out_actions flag] --> B[has_other_actions: 1 bit]
    end

    subgraph "References"
        C[Ref 0: OutList Chain]
        D[Ref 1: ActionList Chain]
    end

    A -.-> C
    B -.-> D

    subgraph "OutList Structure"
        E[Mode: 8 bits] --> F[Message Ref] --> G[Prev OutList Ref]
    end

    subgraph "ActionList Structure"
        H[Action Type: 8 bits] --> I[Action Data] --> J[Prev ActionList Ref]
    end

    C --> E
    D --> H
```


## Examples

### How to create Inner Request


