---
title: "Function declarations and definitions"
sidebarTitle: "Functions"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

Every function declaration or definition follows a common pattern. The general form is:

```func
[<forall declarator>] <return_type> <function_name>(<comma_separated_function_args>) <specifiers> <function_body>
```

where `[ ... ]` represents an optional entry. Here, 

- `<forall declarator>` specifies that it is a polymorphic function. This is optional.
- `<return_type>` is the return type of the function.
- `<function_name>` is the function identifier.
- `<comma_separated_function_args>` is a comma separated list of function arguments, each argument declaring a type and an identifier.
- `<specifiers>` are specifiers that instruct the compiler on how to process the function.
- `<function_body>` is the actual function body, which can be of three kinds: a function declaration (i.e., no body), an assembler function, or a standard function body definition.

## Polymorphism with forall

<Aside type="danger">
  Editing at this moment, do not read 
</Aside>

Before any function declaration or definition, there can be `forall` type variables declarator. It has the following syntax:

A function definition can include a `forall` type variable declaration before its declaration or implementation. The syntax is:

```func
forall <comma_separated_type_variables_names> ->
```

Here, type variable names can be any [identifier](/language/func/literals_identifiers#identifiers) but are typically written in capital letters.

For example,
```func
forall X, Y -> [Y, X] pair_swap([X, Y] pair) {
  [X p1, Y p2] = pair;
  return [p2, p1];
}
```

This function takes a tuple of exactly two elements, where each component can be of any type that fits in a single stack entry. It swaps the two values. For instance:
- `pair_swap([2, 3])` returns `[3, 2]`;
- `pair_swap([1, [2, 3, 4]])` returns `[[2, 3, 4], 1]`.

In this example, `X` and `Y` are [type variables](/language/func/types#polymorphism-with-type-variables). When the function is called, these variables are replaced with actual types, and the function executes accordingly. Even though the function is polymorphic, the compiled assembly code remains the same for any type substitution. This is possible due to the polymorphic nature of stack manipulation operations. However, other forms of polymorphism, such as `ad-hoc` polymorphism with type classes, are not currently supported.

It is important to note that `X` and `Y` must each have a type width of 1, meaning they should fit within a single stack entry. This means you can't use `pair_swap` on a tuple like `[(int, int), int]` because type `(int, int)` has a width of 2, taking up two stack entries instead of one.


## Return type

The return type can be any atomic or composite type, as described in the [Types](types) section. For example, the following function declarations without a body are valid:

```func
int foo();
(int, int) foo'();
[int, int] foo''();
(int -> int) foo'''();
() foo''''();
```

FunC also supports **type inference** with the use of underscore `_` as the return type. For example:
```func
_ pyth(int m, int n) {
  return (m * m - n * n, 2 * m * n, m * m + n * n);
}
```
This is a valid definition of the function `pyth`, which has the inferred type `(int, int) -> (int, int, int)`.
It computes Pythagorean triples based on the given input values.

## Function name

A function name can be any valid [identifier](literals#identifiers). 
Additionally, it may start with the symbols `.` or `~`, which have specific meanings explained in the [special function call notation](expressions#special-function-call-notation) section.
Specifically, refer to this [section](expressions#and-in-function-names) to understand how the symbols `.` or `~` affect the function name.

For example, `udict_add_builder?`, `dict_set`, and `~dict_set` are all valid function names, and each is distinct. These functions are defined in [stdlib.fc](stdlib).

### Special function names
FunC (specifically, the Fift assembler) reserves several function names with predefined [IDs](#method_id):

- [`recv_internal`](#receive-internal) and [`main`](#main) have `id = 0`
- [`recv_external`](#receive-external) has `id = -1`
- [`run_ticktock`]() has `id = -2`

<Aside type="danger">
  Pending link for explanation of `run_ticktock` function.

  Also, what about the "Split prepare" and "Merge install" events? FunC cannot handle those?
</Aside>

Every program must include a function with `id = 0`, meaning it must define either `recv_internal` or `main`, but **not** both.
The `run_ticktock` function is used in ticktock transactions of special smart contracts.

#### Receive internal

The `recv_internal` function is invoked when a smart contract receives **an inbound [internal message]()**. 
Any of the following `recv_internal` declarations can be used. 

```func
() recv_internal(int balance, int msg_value, cell in_msg_cell, slice in_msg_body)
() recv_internal(int msg_value, cell in_msg_cell, slice in_msg_body)
() recv_internal(cell in_msg_cell, slice in_msg_body)
() recv_internal(slice in_msg_body)
() recv_internal()
```

Here, 
- `balance` is the smart contract balance in nanotons after adding the amount `msg_value` in the inbound message. It is an integer.
- `msg_value` is the amount in nanotons included in the inbound message. It is an integer.
- `in_msg_cell` is the inbound message, given as a cell.
- `in_msg_body` is the inbound message body, equal to the body field in `in_msg_cell`. The body is given as a cell slice.

In the above declarations, those with fewer parameters consume slightly less gas, since each unused argument will be dropped after
the [TVM initializes](/tvm/initialization).

<Aside type="danger">
  Even though the FunC compiler allows the permutation of the parameters in `recv_internal`, this can lead to runtime errors. 
  
  For example, the following will compile, but leads to errors during execution,

  ```func
  () recv_internal(slice in_msg_body, int int msg_value, cell in_msg_cell, int balance)
  ```

  Be careful of accidentally permuting the arguments in `recv_internal`. Only use the five possible declarations listed previously for `recv_internal`.
</Aside>


#### Main

`main` is an alias for `recv_internal`. 

If the intention of the code is to handle inbound internal messages, it is preferable to use `recv_internal` over `main`, 
since `recv_internal` states more clearly the intention of the code.

#### Receive external

The `recv_external` function handles **inbound [external messages]()**. It allows declarations similar to those for `recv_internal`:

```func
() recv_external(int balance, int msg_value, cell in_msg_cell, slice in_msg_body)
() recv_external(int msg_value, cell in_msg_cell, slice in_msg_body)
() recv_external(cell in_msg_cell, slice in_msg_body)
() recv_external(slice in_msg_body)
() recv_external()
```

The only difference is that `msg_value` is always `0`, since [external messages cannot carry coins](), as they are created outside the blockchain. 

## Function arguments

A function can receive zero or more argument declarations, each declaration separated by a comma. The following kinds of argument declarations are allowed:

- Ordinary declaration: an argument is declared using **its type** followed by **its name**. 
Example: 

  ```func 
  int foo(int x) {
    return x + 2;
  }
  ```

  Here, `int x` declares an argument named `x` of type `int` in function `foo`.

  An example that declares multiple arguments:

  ```func 
  int foo(int x, int y) {
    return x + y;
  }
  ```

  An example that declares no arguments:
  
  ```func 
  int foo() {
    return 0;
  }

- Unused argument declaration: only its type needs to be specified. Example:
  
  ```func
  int first(int x, int) {
    return x;
  }
  ```
  
  This is a valid function of type `(int, int) -> int`, but the function does not use its second argument.

- Argument with inferred type declaration: If an argument's type is not explicitly declared, it is inferred by the type-checker.
  For example,
  
  ```func
  int inc(x) {
    return x + 1;
  }
  ```

  This defines a function `inc` with the inferred type `int -> int`, meaning `x` is automatically recognized as an `int`.


<Aside>

Even though a function may appear to take multiple arguments, it takes a single [tensor type](types#tensor-types) argument. 
For more details on this distinction, refer to the [function call](expressions#function-call) section.
However, for convenience, the individual components of this tensor are conventionally referred to as function arguments.

</Aside> 

## Specifiers

<Aside type="danger">
  Editing from here onwards
</Aside>

In FunC, function specifiers modify the behavior of functions. There are three types:

1. `impure`
2. `inline`/ `inline_ref`
3. `method_id`

One, multiple, or none can be used in a function declaration. However, they must appear in a specific order (e.g., `impure` must come before `inline`).

### `impure` specifier

The `impure` specifier indicates that a function has side effects, such as modifying contract storage, sending messages, or throwing exceptions.
If a function is not marked as `impure` and its result is unused, the FunC compiler may delete the function call for optimization.

For example, in the [stdlib.fc](/language/func/stdlib) function:

```func
int random() impure asm "RANDU256";
```
Here, `RANDU256` changes the internal state of the random number generator. The `impure` keyword prevents the compiler from removing this function call.

### `inline` specifier

A function marked as `inline` is directly substituted into the code wherever it is called.
Recursive calls are not allowed for inline functions.

**Example**

```func
(int) add(int a, int b) inline {
    return a + b;
}
```
Since the `add` function is marked with the `inline` specifier, the compiler substitutes `add(a, b)` with `a + b` directly in the code, eliminating the function call overhead.

Another example of using `inline` from [ICO-Minter.fc](https://github.com/ton-blockchain/token-contract/blob/f2253cb0f0e1ae0974d7dc0cef3a62cb6e19f806/ft/jetton-minter-ICO.fc#L16):

```func
() save_data(int total_supply, slice admin_address, cell content, cell jetton_wallet_code) impure inline {
  set_data(begin_cell()
            .store_coins(total_supply)
            .store_slice(admin_address)
            .store_ref(content)
            .store_ref(jetton_wallet_code)
           .end_cell()
          );
}
```

### `inline_ref` specifier

When a function is marked with the `inline_ref` specifier, its code is stored in a separate cell. Each time the function is called, TVM executes a `CALLREF` command. This works similarly to `inline`, but with a key difference—since the same cell can be reused multiple times without duplication, `inline_ref` is generally more efficient regarding code size. The only case where `inline` might be preferable is if the function is called just once. However, recursive calls to `inline_ref` functions remain impossible, as TVM cells do not support cyclic references.

### `method_id`

In a TVM program, every function has an internal integer ID that determines how it can be called.
By default, ordinary functions are assigned sequential numbers starting from `1`, while contract get-methods use `crc16` hashes of their names.
The `method_id(<some_number>)` specifier allows you to set a function's ID to a specific value manually.
If no ID is specified, the default is calculated as `(crc16(<function_name>) & 0xffff) | 0x10000`.
If a function has the `method_id` specifier, it can be invoked by its name as a get-method in lite client or TON explorer.

<Aside type="caution" title="Important limitations and recommendations">

  **19-bit limitation**: Method IDs are limited to 19 bits by the TVM assembler, meaning the valid range is **0 to 524,287** (2^19 - 1).

  **Reserved ranges**:
  - **0-999**: Reserved for system functions (approximate range)
  - **Special functions**: `main`/`recv_internal` (id=0), `recv_external` (id=-1), `run_ticktock` (id=-2)
  - **65536+**: Default range for user functions when using automatic generation `(crc16() & 0xffff) | 0x10000`

  **Best practice**: It's recommended to **avoid setting method IDs manually** and rely on automatic generation instead. Manual assignment can lead to conflicts and unexpected behavior.

</Aside>

<details>
<summary><b>Technical details regarding `method_id` parsing</b></summary>

While the FunC compiler can initially accept larger hex values during parsing, the actual limitation comes from the TVM assembler which restricts method IDs to 19 bits (`@procdictkeylen = 19` in Asm.fif).

The parsing of the hexadecimal string for `method_id` is handled by functions in `crypto/common/bigint.hpp` (specifically `AnyIntView::parse_hex_any` called via `td::string_to_int256` and `BigInt<257>::parse_hex`).

`AnyIntView::parse_hex_any` first performs a basic check on the length of the hex string:

```cpp
if ((j - i - (p > 0)) * 4 > (max_size() - 1) * word_shift + word_bits - 2) {
  return 0; // Invalid if too long
}
```

For `BigInt<257>` (which is `td::BigIntG<257, td::BigIntInfo>`):
- `Tr` is `BigIntInfo`.
- `word_bits` (bits in a word) is 64.
- `word_shift` (effective bits used per word in normalization) is 52. (Source: `crypto/common/bigint.hpp`)
- `max_size()` (maximum words for `BigInt<257>`) is `(257 + 52 - 1) / 52 + 1 = 6` words.

Let's plug these values into the length check formula:
`(max_size() - 1) * word_shift + word_bits - 2`
`(6 - 1) * 52 + 64 - 2 = 5 * 52 + 62 = 260 + 62 = 322` bits.

A 65-character hex string represents \( 65 times 4 = 260 \) bits.
The calculated bit limit for the quick check is 322 bits. Since `260` is not greater than `322`, such a number (65 hex digits) can *pass* this initial length check. This check is designed to quickly reject inputs that are grossly too large. The `-2` offers a slight margin.

After this initial parsing into internal `digits_`, `parse_hex_any` calls `normalize_bool_any()`. This function converts the internal representation into a canonical signed form.
If `normalize_bool_any()` returns `false`, it indicates an overflow during this canonicalization. This can happen even if the number passed the initial length check, for example, if a carry propagates such that it requires more than `max_size()` words to represent in the specific signed format, or if the most significant word itself overflows. In such a case, `parse_hex_any` invalidates the `BigInt` and returns `0`, leading to `td::string_to_int256` returning a `null RefInt256` and FunC reporting an "invalid integer constant".
</details>

**Example**
```func
int get_counter() method_id {
  load_data();
  return ctx_counter;
}
```

## Function body 

### Function declaration

A single semicolon `;` indicates that the function is declared but not yet defined. Its definition must appear later in the same file or a different file processed before the current one by the FunC compiler. For example:
  ```func
  int add(int x, int y);
  ```
  This declares a function named `add` with the type `(int, int) → int` but does not define it.

### Assembler function 

An assembler function body definition defines the function using low-level TVM primitives for use in a FunC program. For example:
  ```func
  int add(int x, int y) asm "ADD";
  ```
  This defines the function `add` using the TVM opcode `ADD`, keeping its type as `(int, int) → int`.

  Refer to the [assembler functions](asm-functions) article for more details.

### Standard function

A standard function body uses a block statement, the most common way to define functions. For example:
  ```func
  int add(int x, int y) {
    return x + y;
  }
  ```
  This is a standard definition of the `add` function.
