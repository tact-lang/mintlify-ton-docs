---
title: "Assembler functions"
sidebarTitle: "Assembler functions"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

<Aside type="danger">
    Needs extensive revamp. Maybe use Tact docs as guidance.
</Aside>

## Assembler function body definition

In FunC, functions can be defined directly using assembler code. This is done using the `asm` keyword, followed by one or more assembler commands written as strings.
For example, the following function increments an integer and then negates it:

```func
int inc_then_negate(int x) asm "INC" "NEGATE";
```
â€“ a function that increments an integer and then negates it. Calls to this function will be translated to 2 assembler commands `INC` and `NEGATE`. An alternative way to define the function is:

When called, this function is directly translated into the two assembler commands, `INC` and `NEGATE`.
Alternatively, the function can be written as:

```func
int inc_then_negate'(int x) asm "INC NEGATE";
```
Here, `INC NEGATE` is treated as a single assembler command by FunC, but the Fift assembler correctly interprets it as two separate commands.

<Aside>

  The list of assembler commands can be found here: [TVM instructions](/tvm/instructions).

</Aside>

### Rearranging stack entries

Sometimes, the order in which function arguments are passed may not match the expected order of an assembler command. Similarly, the returned values may need to be arranged differently. While this can be done manually using stack manipulation primitives, FunC automatically handles it.

<Aside>

  When manually rearranging arguments, they are computed in the new order. To overwrite this behavior use [`#pragma compute-asm-ltr`](/language/func/compiler-directives#pragma-compute-asm-ltr).

</Aside>

For instance, the assembler command `STUXQ` takes an integer, a builder, and another integer as input. It then returns the builder and an integer flag indicating whether the operation succeeded. We can define the corresponding function as follows:

```func
(builder, int) store_uint_quite(int x, builder b, int len) asm "STUXQ";
```
However, if we need to rearrange the order of arguments, we can specify them explicitly in the `asm` declaration:

```func
(builder, int) store_uint_quite(builder b, int x, int len) asm(x b len) "STUXQ";
```
So you can indicate the required order of arguments after the `asm` keyword.

This allows us to control the order in which arguments are passed to the assembler command.

Similarly, we can rearrange return values using the following notation:

```func
(int, builder) store_uint_quite(int x, builder b, int len) asm( -> 1 0) "STUXQ";
```

Here, the numbers indicate the order of return values, where `0` represents the deepest stack entry.

Additionally, we can combine these techniques:
```func
(int, builder) store_uint_quite(builder b, int x, int len) asm(x b len -> 1 0) "STUXQ";
```

### Multi-line asms

Multi-line assembler commands, including Fift code snippets, can be defined using triple-quoted strings `"""`.

```func
slice hello_world() asm """
  "Hello"
  " "
  "World"
  $+ $+ $>s
  PUSHSLICE
""";
```
