---
title: "FunC literals"
sidebarTitle: "Literals"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

## Number literals

FunC supports decimal and hexadecimal integer literals, including those with leading zeros.

**Examples of valid integer literals:** `0`, `123`, `-17`, `00987`, and `-0`.

**Examples of valid hexadecimal literals:** `0xef`, `0xEF`, `0x0`, `-0xfFAb`, `0x0001`, and `-0x0`.

## String literals

In FunC, strings are enclosed in double quotes `"`, like `"this is a string"`. 
You can optionally specify a string type after the string literal, such as `"string"u`, where `u` is the string type.

FunC supports the following string types:

- without type – Used for `asm` function definitions and defining a slice constant from an ASCII string.
- `s`— Defines a raw slice constant using its contents (hex-encoded and optionally bit-padded).
- `a`— Creates a slice constant containing a [`MsgAddressInt` structure]() from a given address.

   <Aside type="danger">
       MsgAddressInt structure link is missing!!
   </Aside>

- `u`— Converts an ASCII string into an integer constant, representing its hex values.
- `h`— Generates an integer constant from the first 32 bits of the string's SHA-256 hash.
- `H`— Generates an integer constant from the full 256-bit SHA-256 hash of the string.
- `c`— Generates an integer constant from the `crc32` value of the string.

Special characters like `\n` are not supported in string literals, but you can create multi-line strings by writing the text across multiple lines, 
all surrounded by triple quotes `"""`. The triple quotes syntax also supports the optional string type at the end of the string. 

**Examples**

The following string literals produce these corresponding constants:

- `"string"`  →  `x{737472696e67}` (slice constant), where `737472696e67` is the hexadecimal representation of the slice contents.
- `"abcdef"s` → `x{abcdef}` (slice constant)
- `"Ef8zMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzMzM0vF"a` → `x{9FE6666666666666666666666666666666666666666666666666666666666666667_}` (slice constant 
representing the `MsgAddressInt` structure: `addr_std$10 anycast:none$0 workchain_id:int8=0xFF address:bits256=0x33...33`)
- `"NstK"u` → `0x4e73744b` (integer constant)
- `"transfer(slice, int)"h` → `0x7a62e8a8` (integer constant)
- `"transfer(slice, int)"H` → `0x7a62e8a8ebac41bd6de16c65e7be363bc2d2cbc6a0873778dead4795c13db979` (integer constant)
- `"transfer(slice, int)"c` → `2235694568` (integer constant)

**Example of a multi-line string literal:**

```func
var a = """
   hash me baby one more time
   .... Oh, baby, baby
"""h;     ;; a has value 876244482
```

## Identifiers

FunC allows a broad range of identifiers for functions and variable names.
Any **single-line string** that meets the following conditions qualifies as a valid identifier:

- It **does not** contain special symbols: `;`, `,`, `(`, `)`, `[`, `]`, spaces including tabs, `~`, and `.`.
- It **does not** start as a [comment](comments) or a [string literal](#string-literals) (i.e., with `"` at the beginning).
- It is **not** a [number literal](#number-literals).
- It is **not** an underscore `_`.
- It is **not** a [reserved keyword](reserved-words#reserved-keywords).
- It is **not** a name of a [reserved builtin](reserved-words#reserved-builtins).

Additionally, **function** names in function definitions can start with `.` or `~`.

**Examples of valid identifiers:**

- `query`, `query'`, `query''`
- `elem0`, `elem1`, `elem2`
- `CHECK`
- `_internal_value`
- `message_found?`
- `get_pubkeys&signatures`
- `dict::udict_set_builder`
- `fatal!`

**Examples of less common, but still valid identifiers:**

- `123validname`
- `2+2=2*2`
- `-alsovalidname`
- `0xefefefhahaha`
- `{hehehe}`
- ``pa{--}in"`aaa`"``

**Examples of valid function names:**

- `fun_a`
- `~fun_a?`
- `._how123`

**Examples of invalid identifiers:**

- `take(first)Entry` - contains parentheses `(` and `)`
- `"not_a_string` - starts with a `"`, like a string literal
- `msg.sender` - includes a `.`
- `send_message,then_terminate` - contains a `,`
- `_` - just an underscore, which is not valid on its own
- ``pa;;in"`aaa`"`` - contains `;`
- `{-aaa-}` - it is a comment
- `aa(bb` - contains an opening parenthesis
- `123` - a number literal
- `_+_` - it is a reserved builtin name

**Special identifiers in backticks:**

FunC allows identifiers enclosed in backticks `` ` ``. These identifiers can contain any characters except:

- Newline characters `\n`
- Backticks `` ` `` themselves, except the opening and closing ones.

**Examples of valid backtick identifiers:**

- `` `I'm a variable identifier too` ``
- `` `any symbols ; ~ () are allowed here...` ``

<Aside type="tip"> 
Identifiers in FunC usually follow these naming conventions:

- **Apostrophe `'` at the end:** used when a variable is a modified version of its original value.

  - Example:
      ```
      cell dict' = udict_set(dict, 100, 0, v);
      ```
      Here, function `udict_set` updates key `0` with value `v` in dictionary `dict`. The updated dictionary name is `dict'`.  

- **Question mark (?) at the end:** typically used for boolean variables or functions that return a success flag.
  - Example: 
       ```
       (slice v, int found?) = udict_get?(dict, 100, 0);
       ```
       Here, function `udict_get?` looks up index `0` in dictionary `dict`, and returns the associated value `v` (if found) and a flag 
       `found?` which indicates whether the index was found in the dictionary. 
 </Aside>

## Constants

FunC allows defining **compile-time constants** that are substituted and pre-computed during compilation.

**Syntax:**

```func
const optional-type identifier = value-or-expression;
```

- `optional-type` (e.g., `int` or `slice`) is optional but improves readability and ensures type correctness.
- `value-or-expression`can be a literal or an expression involving literals and previously defined constants.

Multiple constants can be defined in the same `const` declaration by separating them with `,`.

**Example usage:**

```func
const int101 = 101;                      ;; Numeric constant
const str1 = "const1", str2 = "aabbcc"s; ;; Multiple string constants separated with ,
const int int240 = (int101 * 10) << 3;   ;; Constant computed from an expression
const slice str2r = str2;                ;; Constant referencing another constant
```

<Aside type="tip">

Numeric constants are replaced during compilation,
which means that all optimizations and pre-computations apply efficiently.

</Aside>