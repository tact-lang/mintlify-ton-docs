---
title: "FunC statements"
sidebarTitle: "Statements"
noindex: "true"
---

import { Aside } from '/snippets/aside.jsx';

This section describes FunC statements, which can occur anywhere inside function bodies.

## Expression statements
The most common type of statement is the expression statementâ€”an expression followed by `;`.
See the [FunC expressions]() article for details on the allowed expressions.

## Block statement

Block statements are supported as well, creating a new nested scope:
```func
int x = 1;
builder b = begin_cell();
{
  builder x = begin_cell().store_uint(0, 8);
  b = x;
}
x += 1;
```

In this example, the inner block introduces a new `builder` variable named `x`, which exists only within that scope.
The outer `x` remains unchanged and can be used after the block ends.

## Conditional statements

These statements control the flow of the code based on a condition.

### `if...else` statement

When executing an `if...else statement`, first, the specified condition is evaluated. 
If the condition evaluates to an integer different from `0` (see [absence of boolean type](types#no-boolean-type)), the block after the condition is executed. 
Otherwise, if the condition evaluates to `0`, the optional `else` block is executed. If the `else` block is missing, nothing happens, and execution continues further.

Examples:

```func
if (1 < 10) {   ;; The condition evaluates to -1, so the block executes
  do_something();
}
```

```func
if (11 < 10) {   ;; The condition evaluates to 0, so the block does not execute
  do_something();
} 
;; No else is provided. So, execution continues here, after the block.
```

```func
if (11 < 10) {   ;; The condition evaluates to 0, so the block does not execute
  do_something();
} else {         ;; else is provided. So, the else block executes.
  handle_else();
} 
```

Curly brackets `{}` are required in each block of a `if...else` statement.
For example, the following code will not compile:

```func
if (1 < 10) {
  do_something();
} else if (2 > 1) {   ;; else block must have curly brackets
  do_something2();
}
```
because the `else` block must have curly brackets:
```func
if (1 < 10) {
  do_something();
} else {    ;; else block now has curly brackets
  if (2 > 1) { 
    do_something2();
  }
}
```

The above example can be written in a simpler form by using the `elseif` keyword, to avoid the need to write 
several nested curly brackets in the `else` case:
```func
if (1 < 10) {
  do_something();
} elseif (2 > 1) { 
  do_something2();
}
```

In general, the `elseif` keyword is useful for stating several alternative cases:
```func 
if (cond) {
  do_1();
} elseif (cond2) {
  do_2();
} elseif (cond23) {
  do_3();
} else {
  do_4();
}
```

The alternative cases can also include the `elseifnot` keyword, which allows the inclusion of [`ifnot` statements](#ifnot-else-statement) in the alternatives:

```func 
if (cond) {
  do_1();
} elseif (cond2) {  ;; if in else case
  do_2();
} elseifnot (cond23) {  ;; ifnot in else case
  do_3();
} else {
  do_4();
}
```


### `ifnot...else` statement

The `ifnot...else` statement is equivalent to the [`if..else` statement](#if-else-statement) but with the condition negated using the [bitwise `~` operator]().

<Aside type="danger">
   Missing link to bitwise not operator
</Aside>

More specifically:
```func 
ifnot (cond) {
  do_something();
} else {
  handle_else();
}
```
is equivalent to:
```func 
if (~ cond) {  ;; Standard if..else, with condition negated using ~
  do_something();
} else {
  handle_else();
}
```

In other words, if the condition in the `ifnot` evaluates to `0` (see [absence of boolean type](types#no-boolean-type)), the block after the condition is executed. 
Otherwise, if the condition evaluates to an integer different from `0`, the optional `else` block is executed. 
If the `else` block is missing, nothing happens, and execution continues further.

Examples:

```func
ifnot (1 > 10) {   ;; The condition evaluates to 0, the block executes
  do_something();
}
```

```func
ifnot (11 > 10) {   ;; The condition evaluates to -1, the block does not execute
  do_something();
} 
;; No else is provided. Execution continues here, after the block.
```

```func
ifnot (11 > 10) {   ;; The condition evaluates to -1, the block does not execute
  do_something();
} else {         ;; else is provided. The else block executes.
  handle_else();
} 
```

Similarly to the `if...else`, it is possible to use the keyword `elseifnot` to add several alternative cases:
```func 
ifnot (cond) {
  do_1();
} elseifnot (cond2) {
  do_2();
} elseifnot (cond23) {
  do_3();
} else {
  do_4();
}
```

The alternative cases can also include the `elseif` keyword, which allows the inclusion of standard [`if` statements](#if-else-statement) in the alternatives:

```func 
ifnot (cond) {      ;; ifnot
  do_1();
} elseif (cond2) {  ;; if in else case
  do_2();
} elseifnot (cond23) {  ;; ifnot in else case
  do_3();
} else {
  do_4();
}
```

## Loops
FunC supports `repeat`, `while`, and `do { ... } until` loops. The `for` loop is not supported.

### `repeat` loop

The `repeat` loop executes a block of code a specified number of times. 
The number of repetitions should be given as a positive 32-bit integer in the inclusive range from 
`1` to `2^31 - 1` (i.e., `2147483647`). If the value is greater, an error with [exit code 5](), `Integer out of expected range`, will be thrown.

```func
int x = 1;
repeat(10) { ;; Repeats the block 10 times.
  x *= 2;    ;; Each iteration multiplies x by 2.
}
;; x has value 1024
```

```func
int x = 1;
int y = 10;
repeat(y + 6) {  ;; Repeats the block 16 times.
  x *= 2;        ;; Each iteration multiplies x by 2.
}
;; x has value 65536
```

If the specified number of repetitions is equal to `0` or any negative number in the inclusive range from `-2^256` to `-1`, it is ignored, 
and the code block is not executed at all.

```func
int x = 1;
repeat(-1) {  ;; Block does not execute.
  x *= 2;
}
;; x has value 1
```

### `while` loop

The `while` loop continues executing the block of code as long as the given condition evaluates to an integer different from `0`. 
See [absence of boolean type](types#no-boolean-type).

```func
int x = 5; 
while (x < 10) {  ;; Executes the block 5 times.
                  ;; Each iteration increases x by 1.
                  ;; The loop stops when x becomes 10.
  x += 1;
}
;; x has value 10
```

### `until` loop

The `do...until` loop is a post-test loop that executes the block of code at least once and then continues to execute it until the 
given condition evaluates to an integer different from `0`. See [absence of boolean type](types#no-boolean-type).

```func
int x = 0;
do {      ;; The block always executes at least once
  x += 3;
} until (x % 9 == 0);  ;; Executes the block 3 times.
                       ;; Each iteration increases x by 3.
                       ;; The loop stops when x becomes divisible by 9.
;; x has value 9
```

## `try-catch` statement
*Available in FunC since v0.4.0*

The `try` block executes a section of code.
If an error occurs, all changes made within the `try` block are completely rolled back, and the `catch` block is executed instead. The `catch` block receives two arguments:
- `x`: the exception parameter, which can be of any type
- `n`: the error code, an integer


Unlike many other languages, in FunC, all changes are **undone** if an error occurs inside the `try` block. These modifications include updates to local and global variables and changes to storage registers (`c4` for storage, `c5`for action/messages, `c7` for context, etc.).
Any contract storage updates and outgoing messages are also reverted.

However, certain TVM state parameters are not rolled back, such as:
- Codepage settings
- Gas counters
As a result, all gas consumed within the `try` block is still accounted for, and any operations that modify gas limits (e.g., `accept_message` or `set_gas_limit`) will remain in effect.

**Exception parameter handling**

Since the exception parameter can be of any type, which may vary depending on the exception, FunC cannot determine its type at compile time. This requires the developer to manually cast the exception parameter when necessary, as shown in the type-casting example below.


**Examples**

Basic `try-catch` usage:
```func
try {
  do_something();
} catch (x, n) {
  handle_exception();
}
```

Casting the exception parameter:
```func
forall X -> int cast_to_int(X x) asm "NOP";
...
try {
  throw_arg(-1, 100);
} catch (x, n) {
  x.cast_to_int();
  ;; x = -1, n = 100
  return x + 1;
}
```

Variable reset on exception:
```func
int x = 0;
try {
  x += 1;
  throw(100);
} catch (_, _) {
}
```

In this last example, although `x` is incremented inside the `try` block, the modification is **rolled back** due to the exception, so `x` remains `0`.
