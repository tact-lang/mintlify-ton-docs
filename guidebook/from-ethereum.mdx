---
title: "Coming from Ethereum"
---

TODO: 
- priority gas
- account vs contract
- block limit for tx size

import { Aside } from "/snippets/aside.jsx";

Learn how to develop and build on TON coming from the Ethereum (EVM) ecosystem.

<Aside>
  This guide only covers basic principles and tooling around them. If you want
  more practical example, check out [Tokens on Ton](./dapp.mdx)
</Aside>

## Execution model

### Asynchronous blockchain

One of the biggest stepping stones to learn TON development is asynchronous execution model. Messages sent by one contract take time to arrive to another, meaning that the resulting transaction, for incoming message processing, will happen after the current transaction terminates.

So compared to Ethereum, where you can have multiple processed messages and state changes on different contracts in the same atomic transaction, on TON transaction represents state change only for one account and single message processing. That means that a signed, included-in-block unit is called a "transaction" in both chains, however having the differences in execution models, it has different impact.

Here is a table for comparison:

| Action description                                                                             | Ethereum                               | TON                              |
|------------------------------------------------------------------------------------------------|----------------------------------------|----------------------------------|
| Single message processing with state change on one contract                                    | Message call or "internal transaction" | Transaction                      |
| Number of state changes and messages on different accounts produced from initial contract call | Transaction                            | Chain of transactions or "trace" |

Let's explore practical example, liquidity withdrawal on DEX.

On Ethereum it will look like this, single atomic transaction, with multiple contract calls inside it. You can see that this transaction has a single hash and included in one block:

![eth-burn](../resources/images/from-ethereum/burn-tx-eth.png)

The same operation on TON will be different, it will consist of more than 10 transaction, triggered by one another. Each arrow on this image represents a distinct finalized transaction, with its own hash, inclusion block and all the other properties:

![tvm-burn](../resources/images/from-ethereum/burn-tx-ton.png)

If you want to execute a *really big* transaction on Ethereum (or any other EVM-based blockchain) you will have certain limitations: EVM call-depth of 1024 nested calls and block gas limit. With TON asynchronous execution model you can have trace (chain of transactions) of whatever length you want, as long as you have fees to continue it. For example, [trace that resulted from this message](https://tonviewer.com/transaction/e887503f7dac857be80487e3ed0774db962379d1c153e6df7b9b5313c657ab94) consisted of more than 1.5+ million transactions, lasting more than 4000 blocks until its end!

### On-chain get methods

Another radical difference between two chains is get methods, a way to retrieve some data from the contracts without paying any fees. In TON you *can't* synchronously retrieve data from another contract - you can't call get method from another contract during the transaction. 

If you wonder how we can make any DeFi protocol or complicated on-chain system work with these limitation, read an article about on-chain [Request-Response pattern](./examples.mdx).

### Limited contract storage

In Ethereum, you can store as much data as you want in a single contract. Unbounded maps and arrays are considered a normal practice and you will probably see them in most of the contract examples. This is not the case with TON - every smart contract on TON blockchain has a storage size upper limit. That means that you can't implement ERC20-like fungible tokens in the same way as in EVM chain, by using single map inside one contract.

Instead, you should use [sharding](./examples.mdx).

You can read more about TON architecture design choices that have lead to such differences [here](../standard/overview.mdx).