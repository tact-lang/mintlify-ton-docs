---
title: "Telegram Open Network Blockchain"
---

## 1.1 Everything is a bag of cells
All data in the blocks and state of the TΟΝ Blockchain is represented as a collection of cells (cf. [3, 2.5]). Therefore, this chapter begins with a general discussion of cells.

### 1.1.1. TVM cells
Recall that the ΤΟΝ Blockchain, as well as the TON Virtual Machine (TVM; cf. [4]), represents all permanently stored data as a collection or bag of so-called cells. Each cell consists of up to 1023 data bits and up to four references to other cells. Cyclic cell references are not allowed, so the cells are usually organized into trees of cells, or rather directed acyclic graphs (DAGs) of cells. Any value of an abstract algebraic (dependent) data type may be represented (serialized) as a tree of cells. The precise way of representing values of an abstract data type as a tree of cells is expressed by means of a TL-B scheme. A more thorough discussion of different kinds of cells may be found in [4, 3.1].

### 1.1.2. Application to TON Blockchain blocks and state
The above is particularly applicable to the blocks and state of the TON Blockchain, which also are values of certain (quite convoluted) dependent algebraic data types. Therefore, they are serialized according to various TL-B schemes (which are gradually presented throughout this document), and are represented as a collection or bag of cells.

### 1.1.3. The layout of a single cell
Each single cell consists of up to 1023 data bits and up to four references to other cells. When a cell is kept in memory, its exact representation is implementation-dependent. However, there is a standard representation of cells, useful, for instance, for serializing cells for file storage or network transmission. This "standard representation" or "standard layout" CELLREPR(c) of a cell c consists of the following:

* Two descriptor bytes come first, sometimes denoted by `d1` and `d2`. The first of these bytes `d1` equals (in the simplest case) the number of references `0 <= r <= 4` in the cell. The second descriptor byte `d2` encodes the bit length `l` of the data part of the cell as follows: the first seven bits of `d2` equal `floor(l/8)`, the number of complete data bytes present in the cell, while the last bit of `d2` is the completion tag, equal to one if `l` is not divisible by eight. Therefore, `d2 = 2*floor(l/8) + [l mod 8 != 0] = floor(l/8) + ceil(l/8)` (1), where [A] equals one when condition A is true, and zero otherwise.
* Next, `ceil(l/8)` data bytes follow. This means that the `l` data bits of the cell are split into groups of eight, and each group is interpreted as a big-endian 8-bit integer and stored into a byte. If `l` is not divisible by eight, a single binary one and a suitable number of binary zeroes (up to six) are appended to the data bits, and the completion tag (the least significant bit of the descriptor byte `d2`) is set.
* Finally, `r` references to other cells follow. Each reference is normally represented by 32 bytes containing the SHA256 hash of the referenced cell, computed as explained below in 1.1.4.

In this way, the standard representation CELLREPR(c) of a cell `c` with `l` data bits and `r` references is `2 + floor(l/8) + ceil(l/8) + 32*r` bytes long.

### 1.1.4. The SHA256 hash of a cell
The SHA256 hash of a cell c is recursively defined as the SHA256 of the standard representation CELLREPR(c) of the cell in question:
`HASH(c) := SHA256(c) := SHA256(CELLREPR(c))` (2)
Because cyclic cell references are not allowed (the relationships among all cells must constitute a directed acyclic graph, or DAG), the SHA256 hash of a cell is always well-defined. Furthermore, because SHA256 is tacitly assumed to be collision-resistant, we assume that all the cells that we encounter are completely determined by their hashes. In particular, the cell references of a cell c are completely determined by the hashes of the referenced cells, contained in the standard representation CELLREPR(c).

### 1.1.5. Exotic cells
Apart from the ordinary cells (also called simple or data cells) considered so far, cells of other types, called exotic cells, sometimes appear in the actual representations of TON Blockchain blocks and other data structures. Their representation is somewhat different; they are distinguished by having the first descriptor byte `d1 >= 5` (cf. [4, 3.1]).

### 1.1.6. External reference cells
(External) reference cells, which contain the 32-byte SHA256(c) of a "true" data cell e instead of the data cell itself, are one example of exotic cells. These cells can be used in the serialization of a bag of cells corresponding to a TON Blockchain block in order to refer to data cells absent in the serialization of the block itself, but assumed to be present somewhere else (e.g., in the previous state of the blockchain).

### 1.1.7. Transparency of reference cells with respect to most operations
Most cell operations do not observe any reference cells or other "exotic" kinds of cells; they see only data cells, with any reference cell transparently replaced by the cell referred to. For example, when the transparent cell hash HASH' (c) is recursively computed, the hash of a reference cell is set to be equal to the hash of the cell referred to, not the hash of the standard representation of the reference cell.

### 1.1.8. Transparent hash and representation hash of a cell
In this way, `SHA256^b(c) = HASH^b(c)` is the transparent hash of a cell c (or the tree of cells rooted in c). However, sometimes we need to reason about the exact representation of a tree of cells present in a block. To this end, a representation hash HASH (c) is defined, which is not transparent with respect to reference cells and other exotic types of cells. We often say that the representation hash of c is "the" hash of c, because it is the most frequently used hash of a cell.

### 1.1.9. Use of representation hashes for signatures
Signatures are an excellent example of the application of representation hashes. For instance:

* Validators sign the representation hash of a block, not just its transparent hash, because they need to certify that the block does contain the required data, not just some external references to them.
* When external messages are signed and sent by off-chain parties (e.g., human clients using an application to initiate blockchain transactions), if external references may be present in some of these messages, it is the representation hashes of the messages that must be signed.

### 1.1.10. Higher hashes of a cell
In addition to the transparent and representation hashes of a cell c, a sequence of higher hashes `HASH_i(c)`, for `i = 1, 2, ...` may be defined, which eventually stabilizes at `HASH_infinity(c)`. (More detail may be found in [4, 3.1].)


# 2 Message forwarding and delivery guarantees

This chapter discusses the forwarding of messages inside the TON Blockchain, including the Hypercube Routing (HR) and Instant Hypercube Routing (IHR) protocols. It also describes the provisions required to implement the message delivery guarantees and the FIFO ordering guarantee.

## 2.1 Message addresses and next-hop computation

This section explains the computation of transit and next-hop addresses by the variant of the hypercube routing algorithm employed in TON Blockchain. The hypercube routing protocol itself, which uses the concepts and next-hop address computation algorithm introduced in this section, is presented in the next section.

**Account addresses:** The source address and destination address are always present in any message. Normally, they are (full) account addresses. A full account address consists of a workchain\_id (a signed 32-bit big-endian integer defining a workchain), followed by a (usually) 256-bit internal address or account identifier account\_id (which may also be interpreted as an unsigned big-endian integer) defining the account within the chosen workchain. Different workchains may use account identifiers that are shorter or longer than the “standard” 256 bits used in the masterchain (workchain\_id = −1) and in the basic workchain (workchain\_id = 0). To this end, the masterchain state contains a list of all workchains defined so far, along with their account identifier lengths. An important restriction is that the account\_id for any workchain must be at least 64 bits long.
In what follows, we often consider only the case of 256-bit account addresses for simplicity. Only the first 64 bits of the account\_id are relevant for the purposes of message routing and shardchain splitting.

**Source and destination addresses of a message:** Any message has both a source address and a destination address. Its source address is the address of the account (smart contract) that has created the message while processing some transaction; the source address cannot be changed or set arbitrarily, and smart contracts heavily rely on this property. By contrast, when a message is created, any well-formed destination address may be chosen; after that, the destination address cannot be changed.

**External messages with no source or destination address:** Some messages can have no source or no destination address (though at least one of them must be present), as indicated by special flags in the message header. Such messages are the external messages intended for the interaction of the TON Blockchain with the outside world—human users and their cryptowallet applications, off-chain and mixed applications and services, other blockchains, and so on.
External messages are never routed inside the TON Blockchain. Instead, “messages from nowhere” (i.e., with no source address) are directly included into the InMsgDescr of a destination shardchain block (provided some conditions are met) and processed by a transaction in that very block. Similarly, “messages to nowhere” (i.e., with no TON Blockchain destination address), also known as log messages, are also present only in the block containing the transaction that generated such a message.12
Therefore, external messages are almost irrelevant for the discussion of message routing and message delivery guarantees. In fact, the message delivery guarantees for outbound external messages are trivial (at most, the message must be included into the LogMsg part of the block), and for inbound external messages there are none, since the validators of a shardchain block are free to include or ignore suggested inbound external messages at their discretion (e.g., according to the processing fee offered by the message).13
In what follows, we focus on “usual” or “internal” messages, which have both a source and a destination address.

**Transit and next-hop addresses:** When a message needs to be routed through intermediate shardchains before reaching its intended destination, it is assigned a transit address and a next-hop address in addition to the (immutable) source and destination addresses. When a copy of the message resides inside a transit shardchain awaiting its relay to its next hop, the transit address is its intermediate address lying in the transit shardchain, as if belonging to a special message-relay smart contract whose only job is to relay the unchanged message to the next shardchain on the route. The next-hop address is the address in a neighboring shardchain (or, on some rare occasions, in the same shardchain) to which the message needs to be relayed. After the message is relayed, the next-hop address usually becomes the transit address of the copy of the message included in the next shardchain.
Immediately after an outbound message is created in a shardchain (or in the masterchain), its transit address is set to its source address.14

**Computation of the next-hop address for hypercube routing:** The TON Blockchain employs a variant of hypercube routing. This means that the next-hop address is computed from the transit address (originally equal to the source address) as follows:

1. The (big-endian signed) 32-bit workchain\_id components of both the transit address and destination address are split into groups of n1 bits (currently, n1 = 32), and they are scanned from the left (i.e., the most significant bits) to the right. If one of the groups in the transit address differs from the corresponding group in the destination address, then the value of this group in the transit address is replaced by its value in the destination address to compute the next-hop address.

2. If the workchain\_id parts of the transit and destination addresses match, then a similar process is applied to the account\_id parts of the addresses: The account\_id parts, or rather their first (most significant) 64 bits, are split into groups of n2 bits (currently, n2 = 4 bit groups are used, corresponding to the hexadecimal digits of the address) starting from the most significant bit, and are compared starting from the left. The first group that differs is replaced in the transit address with its value in the destination address to compute the next-hop address.

3. If the first 64 bits of the account\_id parts of the transit and destination addresses match as well, then the destination account belongs to the current shardchain, and the message should not be forwarded outside the current shardchain at all. Instead, it must be processed by a transaction inside it.

**Notation for the next-hop address:** We denote by

```
NextHop(ξ, η)  (13)
```

the next-hop address computed for current (source or transit) address ξ and destination address η.

**Support for anycast addresses:** “Large” smart contracts, which can have separate instances in different shardchains, may be reached using anycast destination addresses. These addresses are supported as follows.
An anycast address (η, d) consists of a usual address η along with its “splitting depth” d ≤ 31. The idea is that the message may be delivered to any address differing from η only in the first d bits of the internal address part (i.e., not including the workchain identifier, which must match exactly). This is achieved as follows:

* The effective destination address ˜η is computed from (η, d) by replacing the first d bits of the internal address part of η with the corresponding bits taken from the source address ξ.
* All computations of NextHop(ν, η) are replaced by NextHop(ν, ˜η), for ν = ξ as well as for all other intermediate addresses ν. In this way, Hypercube Routing or Instant Hypercube Routing will ultimately deliver the message to the shardchain containing ˜η.
* When the message is processed in its destination shardchain (the one containing address ˜η), it may be processed by an account η′ of the same shardchain differing from η and ˜η only in the first d bits of the internal address part. More precisely, if the common shard address prefix is s, so that only internal addresses starting with binary string s belong to the destination shard, then η′ is computed from η by replacing the first min(d, |s|) bits of the internal address part of η with the corresponding bits of s.
  That said, we tacitly ignore the existence of anycast addresses and the additional processing they require in the following discussions.

**Hamming optimality of the next-hop address algorithm:** Notice that the specific hypercube routing next-hop computation algorithm explained above may potentially be replaced by another algorithm, provided it satisfies certain properties. One of these properties is the Hamming optimality, meaning that the Hamming (L1) distance from ξ to η equals the sum of Hamming distances from ξ to NextHop(ξ, η) and from NextHop(ξ, η) to η:

```
∥ξ − η∥1 = ∥ξ − NextHop(ξ, η)∥1 + ∥NextHop(ξ, η) − η∥1  (14)
```

Here ∥ξ − η∥1 is the Hamming distance between ξ and η, equal to the number of bit positions in which ξ and η differ:15

```
∥ξ − η∥1 = Σ_i |ξ_i − η_i|  (15)
```

Notice that in general one should expect only an inequality in (14), following from the triangle inequality for the L1-metric. Hamming optimality essentially means that NextHop(ξ, η) lies on one of the (Hamming) shortest paths from ξ to η. It can also be expressed by saying that ν = NextHop(ξ, η) is always obtained from ξ by changing the values of bits at some positions to their values in η: for any bit position i, we have ν\_i = ξ\_i or ν\_i = η\_i.16

**Non-stopping of NextHop:** Another important property of the NextHop is its non-stopping, meaning that NextHop(ξ, η) = ξ is possible only when ξ = η. In other words, if we have not yet arrived at η, the next hop cannot coincide with our current position.
This property implies that the path from ξ to η—i.e., the sequence of intermediate addresses ξ(0) := ξ, ξ(n) := NextHop(ξ(n−1), η)—will gradually stabilize at η: for some N ≥ 0, we have ξ(n) = η for all n ≥ N. Indeed, one can always take N := ∥ξ − η∥1.

**Convexity of the HR path with respect to sharding:** A consequence of Hamming optimality property (14) is what we call the convexity of the path from ξ to η with respect to sharding. Namely, if ξ(0) := ξ, ξ(n) := NextHop(ξ(n−1), η) is the computed path from ξ to η, and N is the first index such that ξ(N) = η, and S is a shard of some workchain in any shard configuration, then the indices i with ξ(i) residing in shard S constitute a subinterval in \[0, N]. In other words, if integers 0 ≤ i ≤ j ≤ k ≤ N are such that ξ(i), ξ(k) ∈ S, then ξ(j) ∈ S as well.
This convexity property is important for some proofs related to message forwarding in the presence of dynamic sharding.

**Internal routing:** Notice that the next-hop address computed according to the rules defined above may belong to the same shardchain as the current one (i.e., the one containing the transit address). In that case, the “internal routing” occurs immediately, the transit address is replaced by the value of the computed next-hop address, and the next-hop address computation step is repeated until a next-hop address lying outside the current shardchain is obtained. The message is then kept in the transit output queue according to its computed next-hop address, with its last computed transit address as the “intermediate owner” of the transit message. If the current shardchain splits into two shardchains before the message is forwarded further, it is the shardchain containing the intermediate owner that inherits this transit message.
Alternatively, we might go on computing the next-hop addresses only to find out that the destination address already belongs to the current shardchain. In that case, the message will be processed (by a transaction) inside this shardchain instead of being forwarded further.

**Neighboring shardchains:** Two shards in a shard configuration—or the two corresponding shardchains—are said to be neighbors, or neighboring shardchains, if one of them contains a next-hop address for at least one combination of allowed source and destination addresses, while the other contains the transit address for the same combination. In other words, two shardchains are neighbors if a message can be forwarded directly from one of them into the other via Hypercube Routing.
The masterchain is also included in this definition, as if it were the only shardchain of the workchain with workchain\_id = −1. In this respect, it is a neighbor of all the other shardchains.

**Any shard is a neighbor of itself:** Notice that a shardchain is always considered a neighbor of itself. This may seem redundant, because we always repeat the next-hop computation described above until we obtain a next-hop address outside the current shardchain. However, there are at least two reasons for such an arrangement:

* Some messages have the source and the destination address inside the same shardchain, at least when the message is created. However, if such a message is not processed immediately in the same block where it has been created, it must be added to the outbound message queue of its shardchain, and be imported as an inbound message (with an entry in the InMsgDescr) in one of the subsequent blocks of the same shardchain.17
* Alternatively, the next-hop address may originally be in some other shardchain that later gets merged with the current shardchain, so that the next hop becomes inside the same shardchain. Then the message will have to be imported from the outbound message queue of the merged shardchain, and forwarded or processed accordingly to its next-hop address, even though they reside now inside the same shardchain.

**Hypercube Routing and the ISP:** Ultimately, the Infinite Sharding Paradigm (ISP) applies here: a shardchain should be considered a provisional union of accountchains, grouped together solely to minimize the block generation and transmission overhead.
The forwarding of a message runs through several intermediate accountchains, some of which can happen to lie in the same shard. In this case, once a message reaches an accountchain lying in this shard, it is immediately (“internally”) routed inside that shard until the last accountchain lying in the same shard is reached. Then the message is enqueued in the output queue of that last accountchain.18

**Representation of transit and next-hop addresses:** Notice that the transit and next-hop addresses differ from the source address only in the workchain\_id and in the first (most significant) 64 bits of the account address. Therefore, they may be represented by 96-bit strings. Furthermore, their workchain\_id usually coincides with the workchain\_id of either the source address or the destination address; a couple of bits may be used to indicate this situation, thus further reducing the space required to represent the transit and next-hop addresses.
In fact, the required storage may be reduced even further by observing that the specific hypercube routing algorithm described above always generates intermediate (i.e., transit and next-hop) addresses that coincide with the destination address in their first k bits, and with the source address in their remaining bits. Therefore, one might use just the values 0 ≤ k\_tr, k\_nh ≤ 96 to fully specify the transit and next-hop addresses. One might also notice that k′ := k\_nh turns out to be a fixed function of k := k\_tr (for instance, k′ = k + n2 = k + 4 for k ≥ 32), and therefore include only one 7-bit value of k in the serialization.
Such optimizations have the obvious disadvantage that they rely too much on the specific routing algorithm used, which can be changed in the future, so they are used in 3.1.15 with a provision to specify more general intermediate addresses if necessary.

**Message envelopes:** The transit and next-hop addresses of a forwarded message are not included in the message itself, but are kept in a special message envelope, which is a cell (or a cell slice) containing the transit and next-hop addresses with the above optimizations, some other information relevant for forwarding and processing, and a reference to a cell containing the unmodified original message. In this way, a message can easily be “extracted” from its original envelope (e.g., the one present in the InMsgDescr) and be put into another envelope (e.g., before being included into the OutMsgQueue).
In the representation of a block as a tree, or rather a DAG, of cells, the two different envelopes will contain references to a shared cell with the original message. If the message is large, this arrangement avoids the need to keep more than one copy of the message in the block.

## 2.2 Hypercube Routing protocol

This section exposes the details of the hypercube routing protocol employed by the TON Blockchain to achieve guaranteed delivery of messages between smart contracts residing in arbitrary shardchains. For the purposes of this document, we will refer to the variant of hypercube routing employed by the TON Blockchain as Hypercube Routing (HR).

**Message uniqueness:** Before continuing, let us observe that any (internal) message is unique. Recall that a message contains its full source address along with its logical creation time, and all outbound messages created by the same smart contract have strictly increasing logical creation times (cf. 1.4.6); therefore, the combination of the full source address and the logical creation time uniquely defines the message. Since we assume the chosen hash function sha256 to be collision resistant, a message is uniquely determined by its hash, so we can identify two messages if we know that their hashes coincide.
This does not extend to external messages “from nowhere”, which have no source addresses. Special care must be taken to prevent replay attacks related to such messages, especially by designers of user wallet smart contracts. One possible solution is to include a sequence number in the body of such messages, and keep the count of external messages already processed inside the smart-contract persistent data, refusing to process an external message if its sequence number differs from this count.

**Identifying messages with equal hashes:** The TON Blockchain assumes that two messages with the same hashes coincide, and treats either of them as a redundant copy of the other. As explained above, this does not lead to any unexpected effects for internal messages. However, if one sends two coinciding “messages from nowhere” to a smart contract, it may happen that only one of them will be delivered—or both. If their action is not supposed to be idempotent (i.e., if processing the message twice has a different effect from processing it once), some provisions should be made to distinguish the two messages, for instance by including a sequence number in them.
In particular, the InMsgDescr and OutMsgDescr use the (unenveloped) message hash as a key, tacitly assuming that distinct messages have distinct hashes. In this way, one can trace the path and the fate of a message across different shardchains by looking up the message hash in the InMsgDescr and OutMsgDescr of different blocks.

**The structure of OutMsgQueue:** Recall that the outbound messages — both those created inside the shardchain, and transit messages previously imported from a neighboring shardchain to be relayed to the next-hop shardchain — are accumulated in the OutMsgQueue, which is part of the state of the shardchain (cf. 1.2.7). In contrast with InMsgDescr and OutMsgDescr, the key in OutMsgQueue is not the message hash, but its next-hop address—or at least its first 96 bits—concatenated with the message hash.
Furthermore, the OutMsgQueue is not just a dictionary (hashmap), mapping its keys into (enveloped) messages. Rather, it is a min-augmented dictionary with respect to the logical creation time, meaning that each node of the Patricia tree representing OutMsgQueue has an additional value (in this case, an unsigned 64-bit integer), and that this augmentation value in each fork node is set to be equal to the minimum of the augmentation values of its children. The augmentation value of a leaf equals the logical creation time of the message contained in that leaf; it need not be stored explicitly.

**Inspecting the OutMsgQueue of a neighbor:** Such a structure for the OutMsgQueue enables the validators of a neighboring shardchain to inspect it to find its part (Patricia subtree) relevant to them (i.e., consisting of messages with the next-hop address belonging to the neighboring shard in question—or having the next-hop address with a given binary prefix), as well as quickly compute the “oldest” (i.e., with the minimum logical creation time) message in that part.
Furthermore, the shard validators do not even need to track the total state of all their neighboring shardchains—they only need to keep and update a copy of their OutMsgQueue, or even of its subtree related to them.

**Logical time monotonicity: importing the oldest message from the neighbors.** The first fundamental local condition of message forwarding, called (message import) (logical time) monotonicity condition, may be summarized as follows:

> While importing messages into the InMsgDescr of a shardchain block from the OutMsgQueues of its neighboring shardchains, the validators must import the messages in the increasing order of their logical time; in the case of a tie, the message with the smaller hash is imported first.

More precisely, each shardchain block contains the hash of a masterchain block (assumed to be “the latest” masterchain block at the time of the shardchain block’s creation), which in turn contains the hashes of the most recent shardchain blocks. In this way, each shardchain block indirectly “knows” the most recent state of all other shardchains, and especially its neighboring shardchains, including their OutMsgQueues.19
Now an alternative equivalent formulation of the monotonicity condition is as follows:

> If a message is imported into the InMsgDescr of the new block, its logical creation time cannot be greater than that of any message left unimported in the OutMsgQueue of the most recent state of any of the neighboring shardchains.

It is this form of the monotonicity condition that appears in the local consistency conditions of the TON Blockchain blocks and is enforced by the validators.

**Witnesses to violations of the message import logical time monotonicity condition:** Notice that if this condition is not fulfilled, a small Merkle proof witnessing its failure may be constructed. Such a proof will contain:

* A path in the OutMsgQueue of a neighbor from the root to a certain message m with small logical creation time.
* A path in the InMsgDescr of the block under consideration showing that the key equal to Hash(m) is absent in InMsgDescr (i.e., that m has not been included in the current block).
* A proof that m has not been included in a preceding block of the same shardchain, using the block header information containing the smallest and the largest logical time of all messages imported into the block (cf. 2.3.4–2.3.7 for more information).
* A path in InMsgDescr to another included message m′, such that either Lt(m′) > Lt(m), or Lt(m′) = Lt(m) and Hash(m′) > Hash(m).

**Deleting a message from OutMsgQueue:** A message must be deleted from OutMsgQueue sooner or later; otherwise, the storage used by OutMsgQueue would grow to infinity. To this end, several “garbage collection rules” are introduced. They allow the deletion of a message from OutMsgQueue during the evaluation of a block only if an explicit special “delivery record” is present in the OutMsgDescr of that block. This record contains either a reference to the neighboring shardchain block that has included the message into its InMsgDescr (the hash of the block is sufficient, but collated material for the block may contain the relevant Merkle proof), or a Merkle proof of the fact that the message has been delivered to its final destination via Instant Hypercube Routing.

**Guaranteed message delivery via Hypercube Routing:** In this way, a message cannot be deleted from the outbound message queue unless it has been either relayed to its next-hop shardchain or delivered to its final destination (cf. 2.2.7). Meanwhile, the message import monotonicity condition (cf. 2.2.5) ensures that any message will sooner or later be relayed into the next shardchain, taking into account other conditions which require the validators to use at least half of the block’s space or gas limits for importing inbound internal messages (otherwise the validators might choose to create empty blocks or import only external messages even in the presence of non-empty outbound message queues at their neighbors).

**Message processing order:** When several imported messages are processed by transactions inside a block, the message processing order conditions ensure that older messages are processed first. More precisely, if a block contains two transactions t and t′ of the same account, which process inbound messages m and m′, respectively, and Lt(m) < Lt(m′), then we must have Lt(t) < Lt(t′).

**FIFO guarantees of Hypercube Routing:** The message processing order conditions, along with the message import monotonicity conditions, imply the FIFO guarantees for Hypercube Routing. Namely, if a smart contract ξ creates two messages m and m′ with the same destination η, and m′ is generated later than m (meaning that m ≺ m′, hence Lt(m) < Lt(m′)), then m will be processed by η before m′. This is so because both messages will follow the same routing steps on the path from ξ to η (the Hypercube Routing algorithm described earlier is deterministic), and in all outbound queues and inbound message descriptions m′ will appear “after” m.20
If message m′ can be delivered to B via Instant Hypercube Routing, this is not necessarily true anymore. Therefore, a simple way of ensuring FIFO message delivery discipline between a pair of smart contracts consists in setting a special bit in the message header preventing its delivery via IHR.

**Delivery uniqueness guarantees of Hypercube Routing:** Notice that the message import monotonicity conditions also imply the uniqueness of the delivery of any message via Hypercube Routing—i.e., that it cannot be imported and processed by the destination smart contract more than once. We will see later in 2.3 that enforcing delivery uniqueness when both Hypercube Routing and Instant Hypercube Routing are active is more complicated.

**An overview of Hypercube Routing:** Let us summarize all routing steps performed to deliver an internal message m created by source account ξ0 to destination account η. We denote by ξk+1 := NextHop(ξk, η), k = 0, 1, 2, . . . the intermediate addresses dictated by HR for forwarding the message m to its final destination η. Let Sk be the shard containing ξk.

* \[Birth] — Message m with destination η is created by a transaction t belonging to an account ξ0 residing in some shardchain S0. The logical creation time Lt(m) is fixed at this point and included into the message m.
* \[ImmediateProcessing?] — If the destination η resides in the same shardchain S0, the message may be processed in the same block it was generated in. In this case, m is included into OutMsgDescr with a flag indicating it has been processed in this very block and need not be forwarded further. Another copy of m is included into InMsgDescr, along with the usual data describing the processing of inbound messages. (Notice that m is not included into the OutMsgQueue of S0.)
* \[InitialInternalRouting] — If m either has a destination outside S0, or is not processed in the same block where it was generated, the internal routing procedure described earlier is applied, until an index k is found such that ξk lies in S0, but ξk+1 = NextHop(ξk, η) does not (i.e., Sk = S0, but Sk+1 ≠ S0). Alternatively, this process stops if ξk = η or ξk coincides with η in its first 96 bits.
* \[OutboundQueuing] — The message m is included into OutMsgDescr (with the key equal to its hash), with an envelope containing its transit address ξk and next-hop address ξk+1 as explained before. The same enveloped message is also included in the OutMsgQueue of the state of Sk, with the key equal to the concatenation of the first 96 bits of its next-hop address ξk+1 (which may be equal to η if η belongs to Sk) and the message hash Hash(m).
* \[QueueWait] — Message m waits in the OutMsgQueue of shardchain Sk to be forwarded further. In the meantime, shardchain Sk may split or merge with other shardchains; in that case, the new shard S′k containing the transit address ξk inherits m in its OutMsgQueue.
* \[ImportInbound] — At some point in the future, the validators for the shardchain Sk+1 containing the next-hop address ξk+1 scan the OutMsgQueue in the state of shardchain Sk and decide to import message m in keeping with the monotonicity condition and other conditions. A new block for shardchain Sk+1 is generated, with an enveloped copy of m included in its InMsgDescr. The entry in InMsgDescr contains also the reason for importing m into this block, with a hash of the most recent block of shardchain S′k, and the previous next-hop and transit addresses ξk and ξk+1, so that the corresponding entry in the OutMsgQueue of S′k can be easily located.
* \[Confirmation] — This entry in the InMsgDescr of Sk+1 also serves as a confirmation for S′k. In a later block of S′k, message m must be removed from the OutMsgQueue of S′k; this modification is reflected in a special entry in the OutMsgDescr of the block of S′k that performs this state modification.
* \[Forwarding?] — If the final destination η of m does not reside in Sk+1, the message is forwarded. Hypercube Routing is applied until some ξl, l > k, and ξl+1 = NextHop(ξl, η) are obtained, such that ξl lies in Sk+1, but ξl+1 does not. After that, a newly-enveloped copy of m with transit address set to ξl and next-hop address ξl+1 is included into both the OutMsgDescr of the current block of Sk+1 and the OutMsgQueue of the new state of Sk+1. The entry of m in InMsgDescr contains a flag indicating that the message has been forwarded; the entry in OutMsgDescr contains the newly-enveloped message and a flag indicating that this is a forwarded message. Then all the steps starting from \[OutboundQueuing] are repeated, for l instead of k.
* \[Processing?] — If the final destination η of m resides in Sk+1, then the block of Sk+1 that imported the message must process it by a transaction t included in the same block. In this case, InMsgDescr contains a reference to t by its logical time Lt(t), and a flag indicating that the message has been processed.

The above message routing algorithm does not take into account some further modifications required to implement Instant Hypercube Routing (IHR). For instance, a message may be discarded after being imported (listed in InMsgDescr) into its final or intermediate shardchain block, because a proof of delivery via IHR to the final destination is presented. In this case, such a proof must be included into InMsgDescr to explain why the message was not forwarded further or processed.

## 2.3 Instant Hypercube Routing and combined delivery guarantees

This section describes the Instant Hypercube Routing protocol, normally applied by TON Blockchain in parallel to the previously discussed Hypercube Routing protocol to achieve faster message delivery. However, when both Hypercube Routing and Instant Hypercube Routing are applied to the same message in parallel, achieving delivery and unique delivery guarantees is more complicated. This topic is also discussed in this section.

**An overview of Instant Hypercube Routing:** Let us explain the major steps applied when the Instant Hypercube Routing (IHR) mechanism is applied to a message. (Notice that normally both the usual HR and IHR work in parallel for the same message; some provisions must be taken to guarantee the uniqueness of delivery of any message.)
Consider the routing and delivery of the same message m with source ξ and destination η as discussed earlier:

* \[NetworkSend] — After the validators of S0 have agreed on and signed the block containing the creating transaction t for m, and observed that the destination η of m does not reside inside S0, they may send a datagram (encrypted network message), containing the message m along with a Merkle proof of its inclusion into the OutMsgDescr of the block just generated, to the validator group of the shardchain T currently owning the destination η.
* \[NetworkReceive] — If the validators of shardchain T receive such a message, they check its validity starting from the most recent masterchain block and the shardchain block hashes listed in it, including the most recent “canonical” block of shardchain S0 as well. If the message is invalid, they silently discard it. If that block of shardchain S0 has a larger sequence number than the one listed in the most recent masterchain block, they may either discard it or postpone the verification until the next masterchain block appears.
* \[InclusionConditions] — The validators check inclusion conditions for message m. In particular, they must check that this message has not been delivered before, and that the OutMsgQueues of the neighbors do not have unprocessed outbound messages with destinations in T with smaller logical creation times than Lt(m).
* \[Deliver] — The validators deliver and process the message, by including it into the InMsgDescr of the current shardchain block along with a bit indicating that it is an IHR message, the Merkle proof of its inclusion into the OutMsgDescr of the original block, and the logical time of the transaction t′ processing this inbound message into the currently generated block.
* \[Confirm] — Finally, the validators send encrypted datagrams to all the validator groups of the intermediate shardchains on the path from ξ to η, containing a Merkle proof of the inclusion of message m into the InMsgDescr of its final destination. The validators of an intermediate shardchain may use this proof to discard the copy of message m travelling by the rules of HR, by importing the message into their InMsgDescr along with the Merkle proof of final delivery and setting a flag indicating that the message has been discarded.

The overall procedure is even simpler than that for Hypercube Routing. Notice, however, that IHR comes with no delivery or FIFO guarantees: the network datagram may be lost in transit, or the validators of the destination shardchain may decide not to act on it, or they may discard it due to buffer overflow. This is the reason why IHR is used as a complement to HR, and not as a replacement.

**Overall eventual delivery guarantees:** Notice that the combination of HR and IHR guarantees the ultimate delivery of any internal message to its final destination. Indeed, the HR by itself is guaranteed to deliver any message eventually, and the HR for message m can be cancelled at an intermediate stage only by a Merkle proof of delivery of m to its final destination (via IHR).

**Overall unique delivery guarantees:** However, the uniqueness of message delivery for the combination of HR and IHR is more difficult to achieve. In particular, one must check the following conditions, and, if necessary, be able to provide short Merkle proofs that they do or don’t hold:

* When a message m is imported into its next intermediate shardchain block via HR, we must check that m has not already been imported via HR.
* When m is imported and processed in its final destination shardchain, we must check that m has not already been processed. If it has, there are three subcases:

  * If m is being considered for import via HR, and it has already been imported via HR, it must not be imported at all.
  * If m is being considered for import via HR, and it has already been imported via IHR (but not HR), then it must be imported and immediately discarded (without being processed by a transaction). This is necessary to remove m from the OutMsgQueue of its previous intermediate shardchain.
  * If m is being considered for import via IHR, and it has already been imported via either IHR or HR, it must not be imported at all.

**Checking whether a message has already been delivered to its final destination:** Consider the following general algorithm for checking whether a message m has already been delivered to its final destination η: One can simply scan the last several blocks belonging to the shardchain containing the destination address, starting from the latest block and working backwards through the previous block references. (If there are two previous blocks—i.e., if a shardchain merge event occurred at some point—one would follow the chain containing the destination address.) The InMsgDescr of each of these blocks can be checked for an entry with key Hash(m). If such an entry is found, the message m has already been delivered, and we can easily construct a Merkle proof of this fact. If we do not find such an entry before arriving at a block B with Lt+(B) < Lt(m), implying that m could not be delivered in B or any of its predecessors, then the message m definitely has not been delivered yet.
The obvious disadvantage of this algorithm is that, if message m is very old (and most likely delivered a long time ago), meaning that it has a small value of Lt(m), then a large number of blocks will need to be scanned before yielding an answer. Furthermore, if the answer is negative, the size of the Merkle proof of this fact will increase linearly with the number of blocks scanned.

**Checking whether an IHR message has already been delivered to its final destination:** To check whether an IHR message m has already been delivered to its destination shardchain, we can apply the general algorithm described above, modified to inspect only the last c blocks for some small constant c (say, c = 8). If no conclusion can be reached after inspecting these blocks, then the validators for the destination shardchain may simply discard the IHR message instead of spending more resources on this check.

**Checking whether an HR message has already been delivered via HR to its final destination or an intermediate shardchain:** To check whether an HR-received message m (or rather, a message m being considered for import via HR) has already been imported via HR, we can use the following algorithm: Let ξk be the transit address of m (belonging to a neighboring shardchain Sk) and ξk+1 be its next-hop address (belonging to the shardchain under consideration). Since we are considering the inclusion of m, m must be present in the OutMsgQueue of the most recent state of shardchain Sk, with ξk and ξk+1 indicated in its envelope. In particular, (a) the message has been included into OutMsgQueue, and we may even know when, because the entry in OutMsgQueue sometimes contains the logical time of the block where it has been added, and (b) it has not yet been removed from OutMsgQueue.
Now, the validators of the neighboring shardchain are required to remove a message from OutMsgQueue as soon as they observe that message (with transit and next-hop addresses ξk and ξk+1 in its envelope) has been imported into the InMsgDescr of the message’s next-hop shardchain. Therefore, (b) implies that the message could have been imported into the InMsgDescr of a preceding block only if this preceding block is very new (i.e., not yet known to the most recent neighboring shardchain block). Therefore, only a very limited number of preceding blocks (typically one or two, at most) need to be scanned by the algorithm described earlier to conclude that the message has not yet been imported.21 In fact, if this check is performed by the validators or collators for the current shardchain themselves, it can be optimized by keeping in memory the InMsgDescrs of the several latest blocks.

**Checking whether an HR message has already been delivered via IHR to its final destination:** Finally, to check whether an HR message has already been delivered to its final destination via IHR, one can use the general algorithm described above. In contrast with the IHR case, we cannot abort the verification process after scanning a fixed number of the latest blocks in the destination shardchain, because HR messages cannot be dropped without a reason.
Instead, we indirectly bound the number of blocks to be inspected by forbidding the inclusion of IHR message m into a block B of its destination shardchain if there are already more than, say, c = 8 blocks B′ in the destination shardchain with Lt+(B′) ≥ Lt(m).
Such a condition effectively restricts the time interval after the creation of message m in which it could have been delivered via IHR, so that only a small number of blocks of the destination shardchain (at most c) will need to be inspected.
Notice that this condition nicely aligns with the modified algorithm described earlier, effectively forbidding the validators from importing the newly-received IHR message if more than c = 8 steps are needed to check that it had not been imported already.

# 3 Messages, message descriptors, and queues

This chapter presents the internal layout of individual messages, message descriptors (such as InMsgDescr or OutMsgDescr), and message queues (such as OutMsgQueue). Enveloped messages (cf. 2.1.16) are also discussed here.

Notice that most general conventions related to messages must be obeyed by all shardchains, even if they do not belong to the basic shardchain; otherwise, messaging and interaction between different workchains would not be possible. It is the interpretation of the message contents and the processing of messages, usually by some transactions, that differs between workchains.

## 3.1 Address, currency, and message layout

This chapter begins with some general definitions, followed by the precise layout of addresses used for serializing source and destination addresses in a message.

**Some standard definitions:** For the reader’s convenience, here are several general TL-B definitions. These are used below in the discussion of address and message layout, but otherwise are not related to the TON Blockchain.

```tl-b
unit$_ = Unit;
true$_ = True;
// EMPTY False;
bool_false$0 = Bool;
bool_true$1 = Bool;
nothing$0 {X:Type} = Maybe X;
just$1 {X:Type} value:X = Maybe X;
left$0 {X:Type} {Y:Type} value:X = Either X Y;
right$1 {X:Type} {Y:Type} value:Y = Either X Y;
pair$_ {X:Type} {Y:Type} first:X second:Y = Both X Y;
bit$_ _:(## 1) = Bit;
```

**TL-B scheme for addresses:** The serialization of source and destination addresses is defined by the following scheme:

```tl-b
addr_none$00 = MsgAddressExt;
addr_extern$01 len:(## 8) external_address:(len * Bit) = MsgAddressExt;
anycast_info$_ depth:(## 5) rewrite_pfx:(depth * Bit) = Anycast;
addr_std$10 anycast:(Maybe Anycast) workchain_id:int8 address:uint256 = MsgAddressInt;
addr_var$11 anycast:(Maybe Anycast) addr_len:(## 9) workchain_id:int32 address:(addr_len * Bit) = MsgAddressInt;
_ MsgAddressInt = MsgAddress;
_ MsgAddressExt = MsgAddress;
```

The two last lines define type `MsgAddress` as the union of `MsgAddressInt` and `MsgAddressExt`. In this way, `MsgAddress` has four constructors, and `MsgAddressInt` and `MsgAddressExt` are both subtypes.

**External addresses:** The constructors `addr_none` and `addr_extern` are used for source addresses of “messages from nowhere” (inbound external messages), and for destination addresses of “messages to nowhere” (outbound external messages).
The `addr_extern` constructor defines an “external address,” which is ignored by the TON Blockchain software but may be used by external software. For example, an external service might parse this field as an IP address and port, then send a datagram with a copy of the message to that address.

**Internal addresses:** The constructors `addr_std` and `addr_var` represent internal addresses.

* `addr_std` encodes an 8-bit signed `workchain_id` and a 256-bit internal address.
* `addr_var` supports larger `workchain_id` values or addresses of length not equal to 256 bits.

Both allow an optional `anycast` value, which enables address rewriting when present. Validators must use `addr_std` whenever possible, but accept `addr_var` in inbound messages.

**Representing Gram currency amounts:** Amounts of Grams are expressed using variable-length integers and a dedicated `Grams` type:

```tl-b
var_uint$_ {n:#} len:(#< n) value:(uint (len * 8)) = VarUInteger n;
var_int$_ {n:#} len:(#< n) value:(int (len * 8)) = VarInteger n;
nanograms$_ amount:(VarUInteger 16) = Grams;
```

To represent `x` nanograms, choose `ℓ < 16` such that `x < 2^(8ℓ)`, then encode ℓ as a 4-bit int, followed by `x` as an 8ℓ-bit integer.

The original Gram supply was fixed at 5 billion (≈ 5·10¹⁸ nanograms). In practice, 64-bit integers suffice for most computations, though serialization uses TL-B.

**Representing collections of arbitrary currencies:** Users can define arbitrary tokens with 32-bit `currency_id`s stored in masterchain config. Amounts are represented as a dictionary:

```tl-b
extra_currencies$_ dict:(HashmapE 32 (VarUInteger 32)) = ExtraCurrencyCollection;
currencies$_ grams:Grams other:ExtraCurrencyCollection = CurrencyCollection;
```

An internal message value is a `CurrencyCollection`, describing both nanograms and optional extra tokens.

**Message layout:** A message has a header and a body (payload). The header is standardized:

```tl-b
int_msg_info$0 ihr_disabled:Bool bounce:Bool
  src:MsgAddressInt dest:MsgAddressInt
  value:CurrencyCollection ihr_fee:Grams fwd_fee:Grams
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

ext_in_msg_info$10 src:MsgAddressExt dest:MsgAddressInt
  import_fee:Grams = CommonMsgInfo;

ext_out_msg_info$11 src:MsgAddressInt dest:MsgAddressExt
  created_lt:uint64 created_at:uint32 = CommonMsgInfo;

tick_tock$_ tick:Bool tock:Bool = TickTock;

_ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
  code:(Maybe ^Cell) data:(Maybe ^Cell) library:(Maybe ^Cell) = StateInit;

message$_ {X:Type} info:CommonMsgInfo
  init:(Maybe (Either StateInit ^StateInit))
  body:(Either X ^X) = Message X;
```

`Message X` describes a message with payload type `X`. It includes `CommonMsgInfo`, which differs for internal, inbound external, or outbound external messages. Internal messages may carry Gram and token values and always include creation time (`created_lt`, `created_at`).

**Forwarding and IHR fees:** Internal messages define `ihr_fee` and `fwd_fee`. The total deducted from the sender is:

```
total = value + ihr_fee + fwd_fee
```

Only `value` is always credited to the destination; `fwd_fee` is split among HR validators, while `ihr_fee` goes to either validators (via IHR) or the destination account.

**Code and data portions contained in a message:** Messages may carry `code` and `data` for contract initialization, such as constructor messages. If the destination has no code/data and the provided hashes match the address, these are adopted.

**Using code and data for other purposes:** Non-basic workchains can interpret `code`, `data`, and `library` fields arbitrarily. Messaging makes no assumptions.

**Absence of explicit gas price and gas limit:** Messages don’t encode gas price/limit. Gas price is set globally in config. Initial gas limit defaults are set per workchain, bounded by message value ÷ gas price for internal messages. For external messages, the initial limit is small, with the contract adjusting when accepting the message.

**Deserialization of a message payload:** Payloads are parsed by the receiving contract in TVM. The blockchain assumes only that unparsed bits/references after the header belong to the payload.

**Messages with empty payloads:** An empty payload cell is a conventional value-transfer message. Contracts are expected to accept them quietly, but may also use them to trigger logic (e.g., balance checks or deferred actions). Even if rejected, the value is still credited to the destination.

**Message source address and logical creation time determine its generating block:** Together, these two values uniquely identify the block of origin (since each shardchain assigns non-overlapping logical time ranges to blocks).

**Enveloped messages:** Message envelopes attach routing metadata (transit/next-hop addresses, forwarding fee remaining) to a referenced `Message`.

```tl-b
interm_addr_regular$0 use_src_bits:(#<= 96) = IntermediateAddress;
interm_addr_simple$10 workchain_id:int8 addr_pfx:(64 * Bit) = IntermediateAddress;
interm_addr_ext$11 workchain_id:int32 addr_pfx:(64 * Bit) = IntermediateAddress;

msg_envelope cur_addr:IntermediateAddress
  next_addr:IntermediateAddress fwd_fee_remaining:Grams
  msg:^(Message Any) = MsgEnvelope;
```

---

## 3.2 Inbound message descriptors

This section discusses InMsgDescr, the structure containing a description of all inbound messages imported into a block.25

**Types and sources of inbound messages:** Each inbound message mentioned in InMsgDescr is described by a value of type InMsg (an “inbound message descriptor”), which specifies the source of the message, the reason for its being imported into this block, and some information about its “fate”—its processing by a transaction or forwarding inside the block.
Inbound messages may be classified as follows:

* **Inbound external messages** — Need no additional reason for being imported into the block, but must be immediately processed by a transaction in the same block.
* **Internal IHR messages with destination addresses in this block** — The reason for their being imported into the block includes a Merkle proof of their generation (i.e., their inclusion in OutMsgDescr of their original block). Such a message must be immediately delivered to its final destination and processed by a transaction.
* **Internal messages with destinations in this block** — The reason for their inclusion is their presence in OutMsgQueue of the most recent state of a neighboring shardchain,26 or their presence in OutMsgDescr of this very block. This neighboring shardchain is completely determined by the transit address indicated in the forwarded message envelope, which is replicated in InMsg as well. The “fate” of this message is again described by a reference to the processing transaction inside the current block.
* **Immediately routed internal messages** — Essentially a subclass of the previous class of messages. In this case, the imported message is one of the outbound messages generated in this very block.
* **Transit internal messages** — Have the same reason for inclusion as the previous class of messages. However, they are not processed inside the block, but internally forwarded into OutMsgDescr and OutMsgQueue. This fact, along with a reference to the new envelope of the transit message, must be registered in InMsg.
* **Discarded internal messages with destinations in this block** — An internal message with a destination in this block may be imported and immediately discarded instead of being processed by a transaction if it has already been received and processed via IHR in a preceding block of this shardchain. In this case, a reference to the previous processing transaction must be provided.
* **Discarded transit internal messages** — Similarly, a transit message may be discarded immediately after import if it has already been delivered via IHR to its final destination. In this case, a Merkle proof of its processing in the final block (as an IHR message) is required.

**Descriptor of an inbound message:** Each inbound message is described by an instance of the InMsg type, which has six constructors corresponding to the cases listed above:

```tl-b
msg_import_ext$000 msg:^(Message Any) transaction:^Transaction = InMsg;

msg_import_ihr$010 msg:^(Message Any) transaction:^Transaction
  ihr_fee:Grams proof_created:^Cell = InMsg;

msg_import_imm$011 in_msg:^MsgEnvelope
  transaction:^Transaction fwd_fee:Grams = InMsg;

msg_import_fin$100 in_msg:^MsgEnvelope
  transaction:^Transaction fwd_fee:Grams = InMsg;

msg_import_tr$101 in_msg:^MsgEnvelope out_msg:^MsgEnvelope
  transit_fee:Grams = InMsg;

msg_discard_fin$110 in_msg:^MsgEnvelope transaction_id:uint64
  fwd_fee:Grams = InMsg;

msg_discard_tr$111 in_msg:^MsgEnvelope transaction_id:uint64
  fwd_fee:Grams proof_delivered:^Cell = InMsg;
```

Notice that the processing transaction is referred to in the first four constructors directly by a cell reference to Transaction, even though the logical time of the transaction `transaction_lt:uint64` would suffice for this purpose. Internal consistency conditions ensure that the transaction referred to does belong to the destination smart contract indicated in the message, and that the inbound message processed by that transaction is indeed the one being described in this InMsg instance.
Furthermore, notice that `msg_import_imm` could be distinguished from `msg_import_fin` by observing that it is the only case when the logical creation time of the message being processed is greater than or equal to the (minimal) logical time of the block importing the message.

**Collecting forwarding and transit fees from imported messages:** The InMsg structure is also used to indicate the forwarding and transit fees collected from inbound messages. The fee itself is indicated in `ihr_fee`, `fwd_fee`, or `transit_fee` fields; it is absent only in inbound external messages, which use other mechanisms to reward the validators for importing them. The fees must satisfy the following internal consistency conditions:

* For external messages (`msg_import_ext`), there is no forwarding fee.
* For IHR-imported internal messages (`msg_import_ihr`), the fee equals `ihr_fee`, which must coincide with the `ihr_fee` value indicated in the message itself. Notice that `fwd_fee` or `fwd_fee_remaining` are never collected from IHR-imported messages.
* For internal messages delivered to their destination (`msg_import_fin` and `msg_import_imm`), the fee equals the `fwd_fee_remaining` of the enveloped inbound message `in_msg`. Note that it cannot exceed the `fwd_fee` value indicated in the message itself.
* For transit messages (`msg_import_tr`), the fee equals the difference between the `fwd_fee_remaining` values indicated in the `in_msg` and `out_msg` envelopes.
* For discarded messages, the fee also equals the `fwd_fee_remaining` indicated in `in_msg`.

**Imported value of an inbound message:** Each imported message imports some value—a certain amount of one or more cryptocurrencies—into the block. This imported value is computed as follows:

* An external message imports no value.
* An IHR-imported message imports its value plus its `ihr_fee`.
* A delivered or transit internal message imports its value plus its `ihr_fee` plus the value of `fwd_fee_remaining` of its `in_msg` envelope.
* A discarded message imports the `fwd_fee_remaining` of its `in_msg` envelope.

Notice that the forwarding and transit fees collected from an imported message do not exceed its imported value.

**Augmented hashmaps, or dictionaries:** Before continuing, let us discuss the serialization of augmented hashmaps, or dictionaries. Augmented hashmaps are key-value storage structures with n-bit keys and values of some type X, similar to the ordinary hashmaps described in \[4, 3.3]. However, each intermediate node of the Patricia tree representing an augmented hashmap is augmented by a value of type Y.
These augmentation values must satisfy certain aggregation conditions. Typically, Y is an integer type, and the aggregation condition is that the augmentation value of a fork must equal the sum of the augmentation values of its two children. In general, a fork evaluation function `S : Y × Y → Y` or `S : Y → Y → Y` is used instead of the sum. The augmentation value of a leaf is usually computed from the value stored in that leaf by means of a leaf evaluation function `L : X → Y`. The augmentation value of a leaf may be stored explicitly in the leaf along with the value; however, in most cases there is no need for this, because the leaf evaluation function L is very simple.

**Serialization of augmented hashmaps:** The serialization of augmented hashmaps with n-bit keys, values of type X, and augmentation values of type Y is given by the following TL-B scheme, which is an extension of the one provided in \[4, 3.3.3]:

```tl-b
ahm_edge#_ {n:#} {X:Type} {Y:Type} {l:#} {m:#}
  label:(HmLabel ~l n) {n = (~m) + l}
  node:(HashmapAugNode m X Y) = HashmapAug n X Y;

ahmn_leaf#_ {X:Type} {Y:Type} extra:Y value:X
  = HashmapAugNode 0 X Y;

ahmn_fork#_ {n:#} {X:Type} {Y:Type}
  left:^(HashmapAug n X Y) right:^(HashmapAug n X Y) extra:Y
  = HashmapAugNode (n + 1) X Y;

ahme_empty$0 {n:#} {X:Type} {Y:Type} extra:Y
  = HashmapAugE n X Y;

ahme_root$1 {n:#} {X:Type} {Y:Type} root:^(HashmapAug n X Y)
  extra:Y = HashmapAugE n X Y;
```

**Augmentation of InMsgDescr:** The collection of inbound message descriptors is augmented by a vector of two currency values, representing the imported value and the forwarding and transit fees collected from a message or a collection of messages:

```tl-b
import_fees$_ fees_collected:Grams
  value_imported:CurrencyCollection = ImportFees;
```

**Structure of InMsgDescr:** Now the InMsgDescr itself is defined as an augmented hashmap, with 256-bit keys (equal to the representation hashes of imported messages), values of type InMsg, and augmentation values of type ImportFees:

```tl-b
_ (HashmapAugE 256 InMsg ImportFees) = InMsgDescr;
```

This TL-B notation uses an anonymous constructor `_` to define `InMsgDescr` as a synonym for another type.

**Aggregation rules for InMsgDescr:** The fork evaluation and leaf evaluation functions are not included explicitly in the above notation, because the dependent types of TL-B are not expressive enough for this purpose. In words, the fork evaluation function is just the componentwise addition of two `ImportFees` instances, and the leaf evaluation function is defined by the rules listed above for fees and imported values. In this way, the root of the Patricia tree representing an instance of `InMsgDescr` contains an `ImportFees` instance with the total value imported by all inbound messages, and with the total forwarding fees collected from them.

## 4 Accounts and transactions

This chapter discusses the layout of accounts (or smart contracts) and their
state in the TON Blockchain. It also considers transactions, which are the
only way to modify the state of an account, and to process inbound messages
and generate new outbound messages.

## 4.1 Accounts and their states

Recall that a smart contract and an account are the same thing in the context
of the TON Blockchain, and that these terms can be used interchangeably, at
least as long as only small (or “usual”) smart contracts are considered. A large
smart contract may employ several accounts lying in different shardchains of
the same workchain for load balancing purposes.

An account is identified by its full address, and is completely described by
its state. In other words, there is nothing else in an account apart from its
address and state.

### 4.1.1. Account addresses

In general, an account is completely identified by its full address, consisting of a 32-bit workchain_id, and the (usually
256-bit) internal address or account identifier account_id inside the chosen
workchain. In the basic workchain (workchain_id = 0) and in the masterchain (workchain_id = −1) the internal address is always 256-bit. In these
workchains, account_id cannot be chosen arbitrarily, but must be equal
to the hash of the initial code and data of the smart contract; otherwise, it
will be impossible to initialize the account with the intended code and data
(cf. 1.7.3), and to do anything with the accumulated funds in the account
balance.

### 4.1.2. Zero account

By convention, the zero account or account with
zero address accumulates the processing, forwarding, and transit fees, as
well as any other payments collected by the validators of the masterchain
or a workchain. Furthermore, the zero account is a “large smart contract”,
meaning that each shardchain has its instance of the zero account, with the
most significant bits of the address adjusted to lie in the shard. Any funds
transferred to the zero account, intentionally or by accident, are effectively
a gift for the validators. For example, a smart contract might destroy itself
by sending all its funds to the zero account.

### 4.1.3. Small and large smart contracts

By default, smart contracts are
“small”, meaning that they have one account address belonging to exactly
one shardchain at any given moment of time. However, one can create a
“large smart contract of splitting depth d ”, meaning that up to 2^d
instances of the smart contract may be created, with the first d bits of the original
address of the smart contract replaced by arbitrary bit sequences. One can
send messages to such smart contracts using internal anycast addresses with
anycast set to d (cf. 3.1.2). Furthermore, the instances of the large smart
contract are allowed to use this anycast address as the source address of their
generated messages.

An instance of a large smart contract is an account with non-zero maximal
splitting depth d.

### 4.1.4. The three kinds of accounts

There are three kinds of accounts:

- **Uninitialized** — The account only has a balance; its code and data have
not yet been initialized.  
- **Active** — The account’s code and data have been initialized as well.  
- **Frozen** — The account’s code and data have been replaced by a hash,
but the balance is still stored explicitly. The balance of a frozen account
may effectively become negative, reflecting due storage payments.

### 4.1.5. Storage profile of an account

The storage profile of an account is
a data structure describing the amount of persistent blockchain state storage
used by that account. It describes the total amount of cells, data bits, and
internal and external cell references used.

```tl-b
storage_used$_ cells:(VarUInteger 7) bits:(VarUInteger 7)
ext_refs:(VarUInteger 7) int_refs:(VarUInteger 7)
public_cells:(VarUInteger 7) = StorageUsed;
````

The same type StorageUsed may represent the storage profile of a message,
as required, for instance, to compute fwd\_fee, the total forwarding fee for
Hypercube Routing. The storage profile of an account has some additional
fields indicating the last time when the storage fees were exacted:

```tl-b
storage_info$_ used:StorageUsed last_paid:uint32
due_payment:(Maybe Grams) = StorageInfo;
```

The last\_paid field contains either the unixtime of the most recent storage
payment collected (usually this is the unixtime of the most recent transaction), or the unixtime when the account was created (again, by a transaction). The due\_payment field, if present, accumulates the storage payments
that could not be exacted from the balance of the account, represented by a
strictly positive amount of nanograms; it can be present only for uninitialized or frozen accounts that have a balance of zero Grams (but may have
non-zero balances in other cryptocurrencies). When due\_payment becomes
larger than the value of a configurable parameter of the blockchain, the account is destroyed altogether, and its balance, if any, is transferred to the
zero account.

### 4.1.6. Account description

The state of an account is represented by an
instance of type Account, described by the following TL-B scheme:

```tl-b
account_none$0 = Account;
account$1 addr:MsgAddressInt storage_stat:StorageInfo
storage:AccountStorage = Account;
account_storage$_ last_trans_lt:uint64
balance:CurrencyCollection state:AccountState
= AccountStorage;
account_uninit$00 = AccountState;
account_active$1 _:StateInit = AccountState;
account_frozen$01 state_hash:uint256 = AccountState;
acc_state_uninit$00 = AccountStatus;
acc_state_frozen$01 = AccountStatus;
acc_state_active$10 = AccountStatus;
acc_state_nonexist$11 = AccountStatus;
tick_tock$_ tick:Bool tock:Bool = TickTock;
_ split_depth:(Maybe (## 5)) special:(Maybe TickTock)
code:(Maybe ^Cell) data:(Maybe ^Cell)
library:(Maybe ^Cell) = StateInit;
```

Notice that account\_frozen contains the representation hash of an instance
of StateInit, instead of that instance itself, which would otherwise be contained in an account\_active; account\_uninit is similar to account\_frozen,
but it does not contain an explicit state\_hash, because it is assumed to be
equal to the internal address of the account (account\_id), already present
in the addr field. The split\_depth field is present and non-zero only in
instances of large smart contracts. The special field may be present only
in the masterchain—and within the masterchain, only in some fundamental
smart contracts required for the whole system to function.

The storage statistics kept in storage\_stat reflect the total storage usage
of cell slice storage. In particular, the bits and cells used to store the
balance are also reflected in storage\_stat.

When a non-existent account needs to be represented, the account\_none
constructor is used.

### 4.1.7. Account state as a message from an account to its future self

Notice that the account state is very similar to a message sent from
an account to its future self participating in the next transaction, for the
following reasons:

* The account state does not change between two consecutive transactions of the same account, so it is completely similar in this respect to
  a message sent from the earlier transaction to the later one.
* When a transaction is processed, its inputs are an inbound message
  and the previous account state; its outputs are outbound messages
  generated and the next account state. If we treat the state as a special
  kind of message, we see that every transaction has exactly two inputs
  (the account state and an inbound message) and at least one output.
* Both a message and the account state can carry code and data in an
  instance of StateInit, and some value in their balance.
* An account is initialized by a constructor message, which essentially
  carries the future state and balance of the account.
* On some occasions messages are converted into account states, and
  vice versa. For instance, when a shardchain merge event occurs, and
  two accounts that are instances of the same large contract need to be
  merged, one of them is converted into a message sent to the other
  one (cf. 4.2.11). Similarly, when a shardchain split event occurs, and
  an instance of a large smart contract needs to be split into two, this
  is achieved by a special transaction that creates the new instance by
  means of a constructor message sent from the previously existing instance to the new one (cf. 4.2.10).
* One may say that a message is involved in transferring some information across space (between different shardchains, or at least accountchains), while an account state transfers information across time
  (from the past to the future of the same account).

### 4.1.8. Differences between messages and account states

Of course,
there are important differences, too. For example:

* The account state is transferred only “in time” (for a shardchain block to
  its successor), but never “in space” (from one shardchain to another).
  As a consequence, this transfer is done implicitly, without creating
  complete copies of the account state anywhere in the blockchain.
* Storage payments collected by the validators for keeping the account
  state usually are considerably smaller than message forwarding fees for
  the same amount of data.
* When an inbound message is delivered to an account, it is the code
  from the account that is invoked, not the code from the message.

### 4.1.9. The combined state of all accounts in a shard

The split part
of the shardchain state (cf. 1.2.1 and 1.2.2) is given by

```tl-b
_ (HashmapAugE 256 Account CurrencyCollection) = ShardAccounts;
```

This is simply a dictionary with 256-bit account\_ids as keys and corresponding account states as values, sum-augmented by the balances of the accounts.
In this way the sum of balances of all accounts in a shardchain is computed,
so that one can easily check the total amount of cryptocurrency “stored” in
a shard.

Internal consistency conditions ensure that the address of an account
referred to by key k in SmartAccounts is indeed equal to k. An additional
internal consistency condition requires that all keys k begin with the shard
prefix s.

### 4.1.10. Account owner and interface descriptions

One may want to
include some optional information in a controlled account. For example, an
individual user or a company may want to add a text description field to their
wallet account, with the user’s or company’s name or address (or their hash,
if the information should not be made publicly available). Alternatively, a
smart contract may offer a machine-readable or human-readable description
of its supported methods and their intended application, which might be
used by advanced wallet applications to construct drop-down menus and
forms helping a human user to create valid messages to be sent to that smart
contract.

One way of including such information is to reserve, say, the second reference in the data cell of the state of an account for a dictionary with 64-bit
keys (corresponding to some identifiers of the standard types of extra data
one might want to store) and corresponding values. Then a blockchain explorer would be able to extract the required value, along with a Merkle proof
if necessary.

A better way of doing this is by defining some get methods in the smart
contract.

### 4.1.11. Get methods of a smart contract

Get methods are executed by
a stand-alone instance of TVM with the account’s code and data loaded into
it. The required parameters are passed on the stack (say, a magic number
indicating the field to be fetched or the specific get method to be invoked),
and the results are returned on the TVM stack as well (say, a cell slice
containing the serialization of a string with the account owner’s name).

As a bonus, get methods may be used to get answers to more sophisticated queries than just fetching a constant object. For instance, TON DNS
registry smart contracts provide get methods to look up a domain string in
the registry and return the corresponding record, if found.

By convention, get methods use large negative 32-bit or 64-bit indices or
magic numbers, and internal functions of a smart contract use consecutive
positive indices, to be used in TVM’s CALLDICT instruction. The main()
function of a smart contract, used to process inbound messages in ordinary
transactions, always has index zero.


## 4.2 Transactions

According to the Infinite Sharding Paradigm and the actor model, the three
principal components of the TON Blockchain are accounts (along with their
states), messages, and transactions. Previous sections have already discussed
the first two; this section considers transactions.

In contrast with messages, which have essentially the same headers throughout all workchains of the TON Blockchain, and accounts, which have at least
some common parts (the address and the balance), our discussion of transactions is necessarily limited to the masterchain and the basic workchain.
Other workchains may define completely different kinds of transactions.

### 4.2.1. Logical time of a transaction

Each transaction t has a logical
time interval Lt•(t) = [Lt−(t), Lt+(t)) assigned to it (cf. 1.4.6 and 1.4.3).
By convention, a transaction t generating n outbound messages m1, . . . , mn
is assigned a logical time interval of length n + 1, so that

```

Lt+(t) = Lt−(t) + n + 1 . (16)

```

We also set Lt(t) := Lt−(t), and assign the logical creation time of message
mi, where 1 ≤ i ≤ n, by

```

Lt(mi) = Lt−(mi) := Lt−(t) + i, Lt+(mi) := Lt−(mi) + 1 . (17)

````

In this way, each generated outbound message is assigned its own unit interval
inside the logical time interval Lt•(t) of transaction t.

### 4.2.2. Logical time uniquely identifies transactions and outbound messages of an account

Recall that the conditions imposed on logical
time imply that Lt−(t) ≥ Lt+(t0) for any preceding transaction t0 of the same
account ξ, and that Lt−(t) > Lt(m) if m is the inbound message processed
by transaction t. In this way, the logical time intervals of transactions of
the same account do not intersect each other, and as a consequence, the
logical time intervals of all outbound messages generated by an account do
not intersect each other either. In other words, all Lt(m) are different, when
m runs through all outbound messages of the same account ξ.

In this way, Lt(t) and Lt(m), when combined with an account identifier
ξ, uniquely determine a transaction t or an outbound message m of that
account. Furthermore, if one has an ordered list of all transactions of an
account along with their logical times, it is easy to find the transaction that
generated a given outbound message m, simply by looking up the transaction
t with logical time Lt(t) nearest to Lt(m) from below.

### 4.2.3. Generic components of a transaction

Each transaction t contains or indirectly refers to the following data:

- The account ξ to which the transaction belongs.  
- The logical time Lt(t) of the transaction.  
- One or zero inbound messages m processed by the transaction.  
- The number of generated outbound messages n ≥ 0.  
- The outbound messages m1, . . . , mn.  
- The initial state of account ξ (including its balance).  
- The final state of account ξ (including its balance).  
- The total fees collected by the validators.  
- A detailed description of the transaction containing all or some data
  needed to validate it, including the kind of the transaction (cf. 4.2.4)
  and some of the intermediate steps performed.

Of these components, all but the very last one are quite general and might
appear in other workchains as well.

### 4.2.4. Kinds of transactions

There are different kinds of transactions allowed in the masterchain and the shardchains. Ordinary transactions consist
in the delivery of one inbound message to an account, and its processing by
that account’s code; this is the most common kind of transaction. Additionally, there are several kinds of exotic transactions.

Altogether, there are six kinds of transactions:

- **Ordinary transactions** — Belong to an account ξ. They process exactly
  one inbound message m (described in InMsgDescr of the encompassing
  block) with destination ξ, compute the new state of the account, and
  generate several outbound messages (registered in OutMsgDescr) with
  source ξ.  
- **Storage transactions** — Can be inserted by validators at their discretion. They do not process any inbound message and do not invoke any
  code. Their only effect is to collect storage payments from an account,
  affecting its storage statistics and its balance. If the resulting Gram
  balance of the account becomes less than a certain amount, the account
  may be frozen and its code and data replaced by their combined hash.  
- **Tick transactions** — Automatically invoked for certain special accounts
  (smart contracts) in the masterchain that have the tick flag set in
  their state, as the very first transactions in every masterchain block.
  They have no inbound message, but may generate outbound messages
  and change the account state. For instance, validator elections are
  performed by tick transactions of special smart contracts in the masterchain.  
- **Tock transactions** — Similarly automatically invoked as the very last
  transactions in every masterchain block for certain special accounts.  
- **Split transactions** — Invoked as the last transactions of shardchain
  blocks immediately preceding a shardchain split event. They are triggered automatically for instances of large smart contracts that need to
  produce a new instance after splitting.  
- **Merge transactions** — Similarly invoked as the first transactions of
  shardchain blocks immediately after a shardchain merge event, if an
  instance of a large smart contract needs to be merged with another
  instance of the same smart contract.

Notice that out of these six kinds of transactions, only four can occur in the
masterchain, and another subset of four can occur in the basic workchain.

### 4.2.5. Phases of an ordinary transaction

An ordinary transaction
is performed in several phases, which may be thought of as several “subtransactions” tightly bound into one:

- **Storage phase** — Collects due storage payments for the account state
  (including smart-contract code and data, if present) up to the present
  time. The smart contract may be frozen as a result. If the smart
  contract did not exist before, the storage phase is absent.  
- **Credit phase** — The account is credited with the value of the inbound
  message received.  
- **Computing phase** — The code of the smart contract is invoked inside
  an instance of TVM with adequate parameters, including a copy of the
  inbound message and of the persistent data, and terminates with an exit
  code, the new persistent data, and an action list (which includes, for
  instance, outbound messages to be sent). The processing phase may
  lead to the creation of a new account (uninitialized or active), or to
  the activation of a previously uninitialized or frozen account. The gas
  payment, equal to the product of the gas price and the gas consumed,
  is exacted from the account balance.  
- **Action phase** — If the smart contract has terminated successfully (with
  exit code 0 or 1), the actions from the list are performed. If it is
  impossible to perform all of them—for example, because of insufficient
  funds to transfer with an outbound message—then the transaction is
  aborted and the account state is rolled back. The transaction is also
  aborted if the smart contract did not terminate successfully, or if it was
  not possible to invoke the smart contract at all because it is uninitialized
  or frozen.  
- **Bounce phase** — If the transaction has been aborted, and the inbound
  message has its bounce flag set, then it is “bounced” by automatically
  generating an outbound message (with the bounce flag clear) to its
  original sender. Almost all value of the original inbound message (minus gas payments and forwarding fees) is transferred to the generated
  message, which otherwise has an empty body.

### 4.2.6. Bouncing inbound messages to non-existent accounts

Notice
that if an inbound message with its bounce flag set is sent to a previously
non-existent account, and the transaction is aborted (for instance, because
there is no code and data with the correct hash in the inbound message, so
the virtual machine could not be invoked at all), then the account is not
created even as an uninitialized account, since it would have zero balance
and no code and data anyways.31

### 4.2.7. Processing of an inbound message is split between computing and action phases

Notice that the processing of an inbound message is
in fact split into two phases: the computing phase and the action phase.

During the computing phase, the virtual machine is invoked and the necessary
computations are performed, but no actions outside the virtual machine are
taken. In other words, the execution of a smart contract in TVM has no side
effects; there is no way for a smart contract to interact with the blockchain
directly during its execution. Instead, TVM primitives such as SENDMSG
simply store the required action (e.g., the outbound message to be sent) into
the action list being gradually accumulated in TVM control register c5. The
actions themselves are postponed until the action phase, during which the
user smart contract is not invoked at all.

### 4.2.8. Reasons for splitting the processing into computation and action phases

Some reasons for such an arrangement are:

- It is simpler to abort the transaction if the smart contract eventually
  terminates with an exit code other than 0 or 1.  
- The rules for processing output actions may be changed without modifying the virtual machine. (For instance, new output actions may be
  introduced.)  
- The virtual machine itself may be modified or even replaced by another
  one (for instance, in a new workchain) without changing the rules for
  processing output actions.  
- The execution of the smart contract inside the virtual machine is completely isolated from the blockchain and is a pure computation. As a
  consequence, this execution may be virtualized inside the virtual machine itself by means of TVM’s RUNVM primitive, a useful feature for
  validator smart contracts and for smart contracts controlling payment
  channels and other sidechains. Additionally, the virtual machine may
  be emulated inside itself or a stripped-down version of itself, a useful
  feature for validating the execution of smart contracts inside TVM.32

### 4.2.9. Storage, tick, and tock transactions

Storage transactions are
very similar to a stand-alone storage phase of an ordinary transaction. Tick
and tock transactions are similar to ordinary transactions without credit and
bounce phases, because there is no inbound message.

### 4.2.10. Split transactions

Split transactions in fact consist of two transactions. If an account ξ needs to be split into two accounts ξ and ξ′:

- First a **split prepare transaction**, similar to a tock transaction (but in
  a shardchain instead of the masterchain), is issued for account ξ. It
  must be the last transaction for ξ in a shardchain block. The output
  of the processing stage of a split prepare transaction consists not only
  of the new state of account ξ, but also of the new state of account ξ′,
  represented by a constructor message to ξ′ (cf. 4.1.7).  
- Then a **split install transaction** is added for account ξ′, with a reference to the corresponding split prepare transaction. The split install
  transaction must be the only transaction for a previously non-existent
  account ξ′ in the block. It effectively sets the state of ξ′ as defined by
  the split prepare transaction.

### 4.2.11. Merge transactions

Merge transactions also consist of two transactions each. If an account ξ′ needs to be merged into account ξ:

- First a **merge prepare transaction** is issued for ξ′, which converts all of
  its persistent state and balance into a special constructor message with
  destination ξ (cf. 4.1.7).  
- Then a **merge install transaction** for ξ, referring to the corresponding
  merge prepare transaction, processes that constructor message. The
  merge install transaction is similar to a tick transaction in that it must
  be the first transaction for ξ in a block, but it is located in a shardchain
  block, not in the masterchain, and it has a special inbound message.

### 4.2.12. Serialization of a general transaction

Any transaction contains the fields listed in 4.2.3. As a consequence, there are some common
components in all transactions:

```tl-b
transaction$_ account_addr:uint256 lt:uint64 outmsg_cnt:uint15
orig_status:AccountStatus end_status:AccountStatus
in_msg:(Maybe ^(Message Any))
out_msgs:(HashmapE 15 ^(Message Any))
total_fees:Grams state_update:^(MERKLE_UPDATE Account)
description:^TransactionDescr = Transaction;

!merkle_update#02 {X:Type} old_hash:uint256 new_hash:uint256
old:^X new:^X = MERKLE_UPDATE X;
````

The exclamation mark in the TL-B declaration of a merkle\_update indicates
special processing required for such values. In particular, they must be kept
in a separate cell, which must be marked as exotic by a bit in its header
(cf. \[4, 3.1]).

A full explanation of the serialization of TransactionDescr, which describes one transaction according to its kind listed in 4.2.4, can be found
in 4.3.

### 4.2.13. Representation of outbound messages generated by a transaction

The outbound messages generated by a transaction t are kept in
a dictionary out\_msgs with 15-bit keys equal to 0, 1, . . . , n − 1, where
n = outmsg\_cnt is the number of generated outbound messages. Message
mi+1 with index 0 ≤ i < n must have

```
Lt(mi+1) = Lt(t) + i + 1,
Lt(t) = Lt−(t)
```

explicitly stored in the lt field.

### 4.2.14. Consistency conditions for transactions

The common serialization of the fields present in a Transaction, independent of its type and
description, enables us to impose several “external” consistency conditions
on any transaction. The most important of them involves the value flow inside the transaction:

The sum of all inputs (the import value of the inbound
message plus the original balance of the account) must equal the sum of all
outputs (the resulting balance of the account, plus the sum of the export
values of all outbound messages, plus all storage, processing, and forwarding
fees collected by the validators).

In this way, a surface inspection of a transaction, which processes an inbound message with an import value of 1 Gram
received by an account with an initial balance of 10 Grams, generating an
outbound message with an export value of 100 Grams in the process, will
reveal its invalidity even before checking all the details of the TVM execution.

Other consistency conditions may slightly depend on the description of
the transaction. For instance, the inbound message processed by an ordinary
transaction must be registered in the InMsgDescr of the encompassing block,
and the corresponding record must contain a reference to this transaction.
Similarly, all outbound messages generated by all transactions (with the exception of one special message generated by a split prepare or merge prepare
transaction) must be registered in OutMsgDescr.

### 4.2.15. Collection of all transactions of an account

All transactions in
a block belonging to the same account ξ are collected into an “accountchain
block” AccountBlock, which essentially is a dictionary transactions with
64-bit keys, each equal to the logical time of the corresponding transaction:

```tl-b
acc_trans$_ account_addr:uint256
transactions:(HashmapAug 64 ^Transaction Grams)
state_update:^(MERKLE_UPDATE Account)
= AccountBlock;
```

The transactions dictionary is sum-augmented by a Grams value, which
aggregates the total fees collected from these transactions.

In addition to this dictionary, an AccountBlock contains a Merkle update
(cf. \[4, 3.1]) of the total state of the account. If an account did not exist
before the block, its state is represented by an account\_none.

### 4.2.16. Consistency conditions for AccountBlocks

There are several
general consistency conditions imposed on an AccountBlock. In particular:

* The transaction appearing as a value in the augmented transactions
  dictionary must have its lt value equal to its key.
* All transactions must belong to an account whose address account\_addr
  is indicated in the AccountBlock.
* If t and t0 are two transactions with Lt(t) < Lt(t0), and their keys are
  consecutive in transactions, meaning that there is no transaction t00
  with Lt(t) < Lt(t00) < Lt(t0), then the final state of t must correspond
  to the initial state of t0 (their hashes as explicitly indicated in the Merkle
  updates must be equal).
* If t is the transaction with minimal Lt(t), its initial state must coincide
  with the initial state as indicated in state\_update of the AccountBlock.
* If t is the transaction with maximal Lt(t), its final state must coincide
  with the final state as indicated in state\_update of the AccountBlock.
* The list of transactions must be non-empty.

These conditions simply express the fact that the state of an account may
change only as the result of performing a transaction.

### 4.2.17. Collection of all transactions in a block

All transactions in a
block are represented by (cf. 1.2.1):

```tl-b
_ (HashmapAugE 256 AccountBlock Grams) = ShardAccountBlocks;
```

### 4.2.18. Consistency conditions for the collection of all transactions

Again, consistency conditions are imposed on this structure, requiring that
the value at key ξ be an AccountBlock with address equal to ξ. Further
consistency conditions relate this structure with the initial and final states
of the shardchain indicated in the block, requiring that:

* If ShardAccountBlock has no key ξ, then the state of account ξ in the
  initial and in the final state of the block must coincide (or it must be
  absent from both).
* If ξ is present in ShardAccountBlock, its initial and final states as indicated in AccountBlock must match those indicated in the initial and
  final states of the shardchain block, expressed by instances of ShardAccounts (cf. 4.1.9).

These conditions express that the shardchain state is indeed composed out
of the states of separate accountchains.


## 4.3 Transaction descriptions

This section presents the specific TL-B schemes for transaction descriptions according to the classification provided in 4.2.4.

### 4.3.1. Reasons for omitting data from a transaction description

A transaction description for a blockchain featuring a Turing-complete virtual machine for smart-contract execution is necessarily incomplete. Indeed, a truly complete description would contain all the intermediate states of the virtual machine after each instruction is executed, something that cannot fit into a blockchain block of a reasonable size. Therefore, the description of such a transaction is likely to contain only the total number of steps and the hashes of the initial and final states of the virtual machine. The validation of such a transaction will necessarily involve the execution of the smart contract to reproduce all the intermediate steps and the final result.

If we compress the sequence of all intermediate steps of the virtual machine into just the hashes of the initial and final states, then no transaction details at all need to be included: a validator able to check the execution of the virtual machine by itself would also be able to check all the other actions of the transaction starting from its initial data without these details.

### 4.3.2. Reasons for including data into a transaction description

The above considerations notwithstanding, there are still several reasons to introduce some details in the transaction description:

* We want to impose external consistency conditions on the transaction, so that at least the validity of the value flow inside the transaction and the validity of inbound and outbound messages can be quickly checked without invoking the virtual machine (cf. 4.2.14). This at least guarantees the invariance of the total amount of each cryptocurrency in the blockchain, even if it does not guarantee the correctness of its distribution.
* We want to be able to trace principal state changes of an account (such as its being created, activated, or frozen) by inspecting the data stored in the transaction description, without figuring out the missing details of the transaction. This simplifies the verification of the consistency conditions between the accountchain and shardchain states in a block.
* Finally, certain information—such as the total steps of the virtual machine, the hashes of its initial and final states, the total gas consumed, and the exit code—might considerably simplify the debugging and implementation of the TON Blockchain software. (This information would help a human programmer understand what has happened in a particular blockchain block.)

On the other hand, we want to minimize the size of each transaction, because we want to maximize the number of transactions that can fit into each (bounded-size) block. Therefore, all information not required for one of the above reasons is omitted.

### 4.3.3. Description of a storage phase

The storage phase is present in several kinds of transactions, so a common representation for this phase is used:

```
tr_phase_storage$_ storage_fees_collected:Grams
storage_fees_due:(Maybe Grams)
status_change:AccStatusChange
= TrStoragePhase;

acst_unchanged$0 = AccStatusChange; // x -> x
acst_frozen$10 = AccStatusChange;    // init -> frozen
acst_deleted$11 = AccStatusChange;   // frozen -> deleted
```

### 4.3.4. Description of a credit phase

The credit phase can result in the collection of some due payments:

```
tr_phase_credit$_ due_fees_collected:(Maybe Grams)
credit:CurrencyCollection = TrCreditPhase;
```

The sum of due\_fees\_collected and credit must equal the value of the message received, plus its ihr\_fee if the message has not been received via IHR (otherwise the ihr\_fee is awarded to the validators).

### 4.3.5. Description of a computing phase

The computing phase consists in invoking TVM with correct inputs. On some occasions, TVM cannot be invoked at all (e.g., if the account is absent, not initialized, or frozen, and the inbound message being processed has no code or data fields or these fields have an incorrect hash); this is reflected by corresponding constructors.

```
tr_phase_compute_skipped$0 reason:ComputeSkipReason
= TrComputePhase;

tr_phase_compute_vm$1 success:Bool msg_state_used:Bool
account_activated:Bool gas_fees:Grams
_:^[ gas_used:(VarUInteger 7)
    gas_limit:(VarUInteger 7) gas_credit:(Maybe (VarUInteger 3))
    mode:int8 exit_code:int32 exit_arg:(Maybe int32)
    vm_steps:uint32
    vm_init_state_hash:uint256 vm_final_state_hash:uint256 ]
= TrComputePhase;

cskip_no_state$00 = ComputeSkipReason;
cskip_bad_state$01 = ComputeSkipReason;
cskip_no_gas$10   = ComputeSkipReason;
```

The TL-B construct `_:^[ ... ]` describes a reference to a cell containing the fields listed inside the square brackets. In this way, several fields can be moved from a cell containing a large record into a separate subcell.

### 4.3.6. Skipped computing phase

If the computing phase has been skipped, possible reasons include:

* The absence of funds to buy gas.
* The absence of a state (i.e., smart-contract code and data) in both the account (non-eexisting, uninitialized, or frozen) and the message.
* An invalid state passed in the message (i.e., the state’s hash differs from the expected value) to a frozen or uninitialized account.

### 4.3.7. Valid computing phase

If there is no reason to skip the computing phase, TVM is invoked and the results of the computation are logged. Possible parameters are as follows:

* The success flag is set if and only if exit\_code is either 0 or 1.
* The msg\_state\_used parameter reflects whether the state passed in the message has been used. If it is set, the account\_activated flag reflects whether this has resulted in the activation of a previously frozen, uninitialized or non-existent account.
* The gas\_fees parameter reflects the total gas fees collected by the validators for executing this transaction. It must be equal to the product of gas\_used and gas\_price from the current block header.
* The gas\_limit parameter reflects the gas limit for this instance of TVM. It equals the lesser of either the Grams credited in the credit phase from the value of the inbound message divided by the current gas price, or the global per-transaction gas limit.
* The gas\_credit parameter may be non-zero only for external inbound messages. It is the lesser of either the amount of gas that can be paid from the account balance or the maximum gas credit.
* The exit\_code and exit\_args parameters represent the status values returned by TVM.
* The vm\_init\_state\_hash and vm\_final\_state\_hash parameters are the representation hashes of the original and resulting states of TVM, and vm\_steps is the total number of steps performed by TVM (usually equal to two plus the number of instructions executed, including implicit RETs).33

### 4.3.8. Description of the action phase

The action phase occurs after a valid computation phase. It attempts to perform the actions stored by TVM during the computing phase into the action list. It may fail, because the action list may turn out to be too long, contain invalid actions, or contain actions that cannot be completed (for instance, because of insufficient funds to create an outbound message with the required value).

```
tr_phase_action$_ success:Bool valid:Bool no_funds:Bool
status_change:AccStatusChange
total_fwd_fees:(Maybe Grams) total_action_fees:(Maybe Grams)
result_code:int32 result_arg:(Maybe int32) tot_actions:int16
spec_actions:int16 msgs_created:int16
action_list_hash:uint256 tot_msg_size:StorageUsed
= TrActionPhase;
```

### 4.3.9. Description of the bounce phase

```
tr_phase_bounce_negfunds$00 = TrBouncePhase;
tr_phase_bounce_nofunds$01 msg_size:StorageUsed
req_fwd_fees:Grams = TrBouncePhase;
tr_phase_bounce_ok$1 msg_size:StorageUsed
msg_fees:Grams fwd_fees:Grams = TrBouncePhase;
```

### 4.3.10. Description of an ordinary transaction

```
trans_ord$0000 storage_ph:(Maybe TrStoragePhase)
credit_ph:(Maybe TrCreditPhase)
compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
aborted:Bool bounce:(Maybe TrBouncePhase)
destroyed:Bool
= TransactionDescr;
```

Several consistency conditions are imposed on this structure:

* action is absent if and only if the computing phase was unsuccessful.
* The aborted flag is set either if there is no action phase or if the action phase was unsuccessful.
* The bounce phase occurs only if the aborted flag is set and the inbound message was bounceable.

### 4.3.11. Description of a storage transaction

A storage transaction consists just of one stand-alone storage phase:

```
trans_storage$0001 storage_ph:TrStoragePhase
= TransactionDescr;
```

### 4.3.12. Description of tick and tock transactions

Tick and tock transactions are similar to ordinary transactions without an inbound message, so there are no credit or bounce phases:

```
trans_tick_tock$001 is_tock:Bool storage:TrStoragePhase
compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
aborted:Bool destroyed:Bool = TransactionDescr;
```

### 4.3.13. Split prepare and install transactions

A split prepare transaction is similar to a tock transaction in a masterchain, but it must generate exactly one special constructor message; otherwise, the action phase is aborted.

```
split_merge_info$_ cur_shard_pfx_len:(## 6)
acc_split_depth:(## 6) this_addr:uint256 sibling_addr:uint256
= SplitMergeInfo;

trans_split_prepare$0100 split_info:SplitMergeInfo
compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
aborted:Bool destroyed:Bool
= TransactionDescr;

trans_split_install$0101 split_info:SplitMergeInfo
prepare_transaction:^Transaction
installed:Bool = TransactionDescr;
```

Notice that the split install transaction for the new sibling account ξ′ refers to its corresponding split prepare transaction of the previously existing account ξ.

### 4.3.14. Merge prepare and install transactions

A merge prepare transaction converts the state and balance of an account into a message, and a subsequent merge install transaction processes this state:

```
trans_merge_prepare$0110 split_info:SplitMergeInfo
storage_ph:TrStoragePhase aborted:Bool
= TransactionDescr;

trans_merge_install$0111 split_info:SplitMergeInfo
prepare_transaction:^Transaction
credit_ph:(Maybe TrCreditPhase)
compute_ph:TrComputePhase action:(Maybe ^TrActionPhase)
aborted:Bool destroyed:Bool
= TransactionDescr;
```

---

## 4.4 Invoking smart contracts in TVM

This section describes the exact parameters with which TVM is invoked during the computing phase of ordinary and other transactions.

### 4.4.1. Smart-contract code

The code of a smart contract is normally a part of the account’s persistent state, at least if the account is active (cf. 4.1.6). However, a frozen or uninitialized (or non-existent) account has no persistent state, with the possible exception of the account’s balance and the hash of its intended state (equal to the account address for uninitialized accounts). In this case, the code must be supplied in the init field of the inbound message being processed by the transaction (cf. 3.1.7).

### 4.4.2. Smart-contract persistent data

The persistent data of a smart contract is kept alongside its code, and remarks similar to those made above in 4.4.1 apply. In this respect, the code and persistent data of a smart contract are just two parts of its persistent state, which differ only in the way they are treated by TVM during smart-contract execution.

### 4.4.3. Smart-contract library environment

The library environment of a smart contract is a hashmap mapping 256-bit cell (representation) hashes into the corresponding cells themselves. When an external cell reference is accessed during the execution of a smart contract, the cell referred to is looked up in the library environment and the external cell reference is transparently replaced by the cell found.

The library environment for an invocation of a smart contract is computed as follows:

1. The global library environment for the workchain in question is taken from the current state of the masterchain.34
2. Next, it is augmented by the local library environment of the smart contract, stored in the library field of the smart contract’s state. Only 256-bit keys equal to the hashes of the corresponding value cells are taken into account. If a key is present in both the global and local library environments, the local environment takes precedence while merging the two library environments.
3. Finally, the message library stored in the library field of the init field of the inbound message is similarly taken into account. Notice, however, that if the account is frozen or uninitialized, the library field of the message is part of the suggested state of the account, and is used instead of the local library environment in the previous step. The message library has lower precedence than both the local and the global library environments.

### 4.4.4. The initial state of TVM

A new instance of TVM is initialized prior to the execution of a smart contract as follows:

* The original cc (current continuation) is initialized using the cell slice created from the cell code, contaning the code of the smart contract computed as described in 4.4.1
* The cp (TVM codepage) is set to zero. If the smart contract wants to use another TVM codepage x, it must switch to it by using SETCODEPAGE x as the first instruction of its code.
* Control register c0 (return continuation) is initialized by extraordinary continuation ec\_quit with parameter 0. When executed, this continuation leads to a termination of TVM with exit code 0.
* Control register c1 (alternative return continuation) is initialized by extraordinary continuation ec\_quit with parameter 1. When invoked, it leads to a termination of TVM with exit code 1. (Notice that terminating with exit code 0 or 1 is considered a successful termination.)
* Control register c2 (exception handler) is initialized by extraordinary continuation ec\_quit\_exc. When invoked, it takes the top integer from the stack (equal to the exception number) and terminates TVM with exit code equal to that integer. In this way, by default all exceptions terminate the smart-contract execution with exit code equal to the exception number.
* Control register c3 (code dictionary) is initialized by the cell with the smart-contract code, similarly to the initial current continuation (cc).
* Control register c4 (root of persistent data) is initialized by the persistent data of the smart contract.35
* Control register c5 (root of actions) is initialized by an empty cell. The “output action” primitives of TVM, such as SENDMSG, use c5 to accumulate the list of actions (e.g., outbound messages) to be performed upon successful termination of the smart contract (cf. 4.2.7 and 4.2.8).
* Control register c7 (root of temporary data) is initialized by a singleton Tuple, the only component of which is a Tuple containing an instance of SmartContractInfo with smart contract balance and other useful information (cf. 4.4.10). The smart contract may replace the temporary data, especially all components of the Tuple at c7 but the first one, with whatever other temporary data it may require. However, the original content of the SmartContractInfo at the first component of the Tuple held in c7 is inspected and sometimes modified by SENDMSG TVM primitives and other “output action” primitives of TVM.
* The gas limits gas = (gm, gl, gc, gr) are initialized as follows:

  * The maximal gas limit gm is set to the lesser of either the total Gram balance of the smart contract (after the the credit phase—i.e., combined with the value of the inbound message) divided by the current gas price, or the per-execution global gas limit.36
  * The current gas limit gl is set to the lesser of either the Gram value of the inbound message divided by the gas price, or the global per-execution gas limit. In this way, always gl ≤ gm. For inbound external messages gl = 0, since they cannot carry any value.
  * The gas credit gc is set to zero for inbound internal messages, and to the lesser of either gm or a fixed small value (the default external message gas credit, a configurable parameter) for inbound external messages.
  * Finally, the remaining gas limit gr is automatically initialized by gl + gc.

### 4.4.5. The initial stack of TVM for processing an internal message

After TVM is initialized as described in 4.4.4, its stack is initialized by pushing the arguments to the main() function of the smart contract as follows:

* The Gram balance b of the smart contract (after crediting the value of the inbound message) is passed as an Integer amount of nanograms.
* The Gram balance bm of inbound message m is passed as an Integer amount of nanograms.
* The inbound message m is passed as a cell, which contains a serialized value of type Message X, where X is the type of the message body
* The body mb : X of the inbound message, equal to the value of field body of m, is passed as a cell slice.
* Finally, the function selector s, an Integer normally equal to zero, is pushed into the stack.

After that, the code of the smart contract, equal to its initial value of c3, is executed. It selects the correct function according to s, which is expected to process the remaining arguments to the function and terminate afterwards.

### 4.4.6. Processing an inbound external message

An inbound external message is processed similarly to 4.4.4 and 4.4.5, with the following modifications:

* The function selector s is set to −1, not to 0.
* The Gram balance bm of inbound message is always 0.
* The initial current gas limit gl is always 0. However, the initial gas credit gc > 0.

The smart contract must terminate with gc = 0 or gr ≥ gc; otherwise, the transaction and the block containing it are invalid. Validators or collators suggesting a block candidate must never include transactions processing inbound external messages that are invalid.

### 4.4.7. Processing tick and tock transactions

The TVM stack for processing tick and tock transactions (cf. 4.2.4) is initialized by pushing the following values:

* The Gram balance b of the current account in nanograms (an Integer).
* The 256-bit address ξ of the current account inside the masterchain, represented by an unsigned Integer.
* An integer equal to 0 for tick transactions and to −1 for tock transactions.
* The function selector s, equal to −2.

### 4.4.8. Processing split prepare transactions

For processing split prepare transactions (cf. 4.3.13), the TVM stack is initialized by pushing the following values:

* The Gram balance b of the current account.
* A Slice containing SplitMergeInfo (cf. 4.3.13).
* The 256-bit address ξ of the current account.
* The 256-bit address ˜ξ of the sibling account.
* An integer 0 ≤ d ≤ 63, equal to the position of the only bit in which ξ and ˜ξ differ.
* The function selector s, equal to −3.

### 4.4.9. Processing merge install transactions

For processing merge install transactions (cf. 4.3.14), the TVM stack is initialized by pushing the following values:

* The Gram balance b of the current account (already combined with the Gram balance of the sibling account).
* The Gram balance b′ of the sibling account, taken from the inbound message m.
* The message m from the sibling account, automatically generated by a merge prepare transaction. Its init field contains the final state S˜ of the sibling account.
* The state S˜ of the sibling account, represented by a StateInit (cf. 3.1.7).
* A Slice containing SplitMergeInfo (cf. 4.3.13).
* The 256-bit address ξ of the current account.
* The 256-bit address ˜ξ of the sibling account.
* An integer 0 ≤ d ≤ 63, equal to the position of the only bit in which ξ and ˜ξ differ.
* The function selector s, equal to −4.

### 4.4.10. Smart-contract information

The smart-contract information structure SmartContractInfo, passed in the first component of the Tuple contained in control register c7, is also a Tuple containing the following data:

```
[ magic:0x076ef1ea actions:Integer msgs_sent:Integer
  unixtime:Integer block_lt:Integer trans_lt:Integer
  rand_seed:Integer balance_remaining:[Integer (Maybe Cell)]
  myself:MsgAddressInt global_config:(Maybe Cell)
] = SmartContractInfo;
```

In other words, the first component of this tuple is an Integer magic always equal to 0x076ef1ea, the second component is an Integer actions, originally initialized by zero, but incremented by one whenever an output action is installed by a non-RAW output action primitive of the TVM, and so on. The remaining balance is represented by a pair, i.e., a two-component Tuple: the first component is the nanogram balance, and the second component is a dictionary with 32-bit keys representing all other currencies, if any (cf. 3.1.6). The rand\_seed field (an unsigned 256-bit integer) here is initialized deterministically starting from the rand\_seed of the block, the account address, the hash of the inbound message being processed (if any), and the transaction logical time trans\_lt.

### 4.4.11. Serialization of output actions

The output actions of a smart contract are accumulated in a linked list stored in control register c5. The list of output actions is serialized as a value of type OutList n, where n is the length of the list:

```
out_list_empty$_ = OutList 0;
out_list$_ {n:#} prev:^(OutList n) action:OutAction
= OutList (n + 1);

action_send_msg#0ec3c86d out_msg:^(Message Any) = OutAction;
action_set_code#ad4de08e new_code:^Cell = OutAction;
```

# 5 Block layout

This chapter presents the block layout used by the TON Blockchain, combining the data structures described separately in previous chapters to produce a
complete description of a shardchain block. In addition to the TL-B schemes
that define the representation of a shardchain block by a tree of cells, this
chapter describes exact serialization formats for the resulting bags (collections) of cells, which are necessary to represent a shardchain block as a file.
Masterchain blocks are similar to shardchain blocks, but have some additional fields. The necessary modifications are discussed separately in 5.2.

## 5.1 Shardchain block layout

This section lists the data structures that must be contained in a shardchain
block and in the shardchain state, and concludes by presenting a formal TL-B
scheme for a shardchain block.

### 5.1.1. Components of the shardchain state.

The shardchain state consists of:
• ShardAccounts, the split part of the shardchain state (cf. 1.2.2) containing the state of all accounts assigned to this shard (cf. 4.1.9).
• OutMsgQueue, the output message queue of the shardchain (cf. 3.3.6).
• SharedLibraries, the description of all shared libraries of the shardchain
(for now, non-empty only in the masterchain).
• The logical time and the unixtime of the last modification of the state.
• The total balance of the shard.
• A hash reference to the most recent masterchain block, indirectly describing the state of the masterchain and, through it, the state of all
other shardchains of the TON Blockchain (cf. 1.5.2).

### 5.1.2. Components of a shardchain block.

A shardchain block must
contain:
• A list of validator signatures (cf. 1.2.6), which is external with respect
to all other contents of the block
• BlockHeader, containing general information about the block (cf. 1.2.5)
• Hash references to the immediately preceding block or blocks of the
same shardchain, and to the most recent masterchain block.
• InMsgDescr and OutMsgDescr, the inbound and outbound message
descriptors (cf. 3.2.8 and 3.3.5).
• ShardAccountBlocks, the collection of all transactions processed in the
block (cf. 4.2.17) along with all updates of the states of the accounts
assigned to the shard. This is the split part of the shardchain block
(cf. 1.2.2).
• The value flow, describing the total value imported from the preceding
blocks of the same shardchain and from inbound messages, the total
value exported by outbound message, the total fees collected by validators, and the total value remaining in the shard.
• A Merkle update (cf. \[4, 3.1]) of the shardchain state. Such a Merkle
update contains the hashes of the initial and final shardchain states
with respect to the block, along with all new cells of the final state
that have been created while processing the block.37

### 5.1.3. Common parts of the block layout for all workchains.

Recall
that different workchains may define their own rules for processing messages,
other types of transactions, other components of the state, and other ways to
serialize all this data. However, some components of the block and its state
must be common for all workchains in order to maintain the interoperability
between different workchains. Such common components include:
• OutMsgQueue, the outbound message queue of a shardchain, which is
scanned by neighboring shardchains for messages addressed to them.
• The outer structure of InMsgDescr as a hashmap with 256-bit keys
equal to the hashes of the imported messages. (The inbound message
descriptors themselves need not have the same structure.)
• Some fields in the block header identifying the shardchain and the
block, along with the paths from the block header to the other information indicated in this list.
• The value flow information.

### 5.1.4. TL-B scheme for the shardchain state.

The shardchain state
(cf. 1.2.1 and 5.1.1) is serialized according to the following TL-B scheme:

```
ext_blk_ref$_ start_lt:uint64 end_lt:uint64
seq_no:uint32 hash:uint256 = ExtBlkRef;
master_info$_ master:ExtBlkRef = BlkMasterInfo;
shard_ident$00 shard_pfx_bits:(## 6)
workchain_id:int32 shard_prefix:uint64 = ShardIdent;
shard_state shard_id:ShardIdent
out_msg_queue:OutMsgQueue
total_balance:CurrencyCollection
total_validator_fees:CurrencyCollection
accounts:ShardAccounts
libraries:(HashmapE 256 LibDescr)
master_ref:(Maybe BlkMasterInfo)
custom:(Maybe ^McStateExtra)
= ShardState;
```

The field custom is usually present only in the masterchain and contains all
the masterchain-specific data. However, other workchains may use the same
cell reference to refer to their specific state data.

### 5.1.5. Shared libraries description.

Shared libraries currently can be
present only in masterchain blocks. They are described by an instance of
HashmapE(256, LibDescr), where the 256-bit key is the representation hash
of the library, and LibDescr describes one library:

```
shared_lib_descr$00 lib:^Cell publishers:(Hashmap 256 True)
= LibDescr;
```

Here publishers is a hashmap with keys equal to the addresses of all accounts that have published the corresponding shared library. The shared
library is preserved as long as at least one account keeps it in its published
libraries collection.

### 5.1.6. TL-B scheme for an unsigned shardchain block.

The precise
format of an unsigned (cf. 1.2.6) shardchain block is given by the following
TL-B scheme:

```
block_info version:uint32
not_master:(## 1)
after_merge:(## 1) before_split:(## 1) flags:(## 13)
seq_no:# vert_seq_no:#
shard:ShardIdent gen_utime:uint32
start_lt:uint64 end_lt:uint64
master_ref:not_master?^BlkMasterInfo
prev_ref:seq_no?^(BlkPrevInfo after_merge)
prev_vert_ref:vert_seq_no?^(BlkPrevInfo 0)
= BlockInfo;
prev_blk_info#_ {merged:#} prev:ExtBlkRef
prev_alt:merged?ExtBlkRef = BlkPrevInfo merged;
unsigned_block info:^BlockInfo value_flow:^ValueFlow
state_update:^(MERKLE_UPDATE ShardState)
extra:^BlockExtra = Block;
block_extra in_msg_descr:^InMsgDescr
out_msg_descr:^OutMsgDescr
account_blocks:ShardAccountBlocks
rand_seed:uint256
custom:(Maybe ^McBlockExtra) = BlockExtra;
```

The field custom is usually present only in the masterchain and contains all
the masterchain-specific data. However, other workchains may use the same
cell reference to refer to their specific block data.

### 5.1.7. Description of total value flow through a block.

The total value
flow through a block is serialized according to the following TL-B scheme:

```
value_flow _:^[ from_prev_blk:CurrencyCollection
to_next_blk:CurrencyCollection
imported:CurrencyCollection
exported:CurrencyCollection ]
fees_collected:CurrencyCollection
_:^[
fees_imported:CurrencyCollection
created:CurrencyCollection
minted:CurrencyCollection
] = ValueFlow;
```

Recall that \_:ˆ\[. . . ] is a TL-B construction indicating that a group of fields
has been moved into a separate cell. The last three fields may be non-zero
only in masterchain blocks.

### 5.1.8. Signed shardchain block.

A signed shardchain block is just an
unsigned block augmented by a collection of validator signatures:

```
ed25519_signature#5 R:uint256 s:uint256 = CryptoSignature;
signed_block block:^Block blk_serialize_hash:uint256
signatures:(HashmapE 64 CryptoSignature)
= SignedBlock;
```

The serialization hash blk\_serialize\_hash of the unsigned block block is
essentially a hash of a specific serialization of the block into an octet string
(cf. 5.3.12 for a more detailed explanation). The signatures collected in
signatures are Ed25519-signatures (cf. A.3) made with a validator’s private
keys of the sha256 of the concatenation of the 256-bit representation hash of
the block block and of its 256-bit serialization hash blk\_serialize\_hash.
The 64-bit keys in dictionary signatures represent the first 64 bits of the
public keys of the corresponding validators.

### 5.1.9. Serialization of a signed block.

The overall procedure of serializing
and signing a block may be described as follows:

1. An unsigned block B is generated, transformed into a complete bag of
   cells (cf. 5.3.2), and serialized into an octet string SB.
2. Validators sign the 256-bit combined hash
   HB := sha256
   Hash∞(B). HashM(SB)
   
   (18)
   of the representation hash of B and of the Merkle hash of its serialization SB
3. A signed shardchain block B˜ is generated from B and these validator
   signatures as described above (cf. 5.1.8).
4. This signed block B˜ is transformed into an incomplete bag of cells,
   which contains only the validator signatures, but the unsigned block
   itself is absent from this bag of cells, being its only absent cell.
5. This incomplete bag of cells is serialized, and its serialization is prepended
   to the previously constructed serialization of the unsigned block.
   The result is the serialization of the signed block into an octet string. It may
   be propagated by network or stored into a disk file.

# 5.2 Masterchain block layout

Masterchain blocks are very similar to shardchain blocks of the basic workchain. This section lists some of the modifications needed to obtain the
description of a masterchain block from the description of a shardchain block
given in 5.1.

### 5.2.1. Additional components present in the masterchain state.

In
addition to the components listed in 5.1.1, the masterchain state must contain:
• ShardHashes — Describes the current shard configuration, and contains
the hashes of the latest blocks of the corresponding shardchains.
• ShardFees — Describes the total fees collected by the validators of each
shardchain.
• ShardSplitMerge — Describes future shard split/merge events. It is
serialized as a part of ShardHashes.
• ConfigParams — Describes the values of all configurable parameters of
the TON Blockchain.

### 5.2.2. Additional components present in masterchain blocks.

In
addition to the components listed in 5.1.2, each masterchain block must
contain:
• ShardHashes — Describes the current shard configuration, and contains the hashes of the latest blocks of the corresponding shardchains.
(Notice that this component is also present in the masterchain state.)

### 5.2.3. Description of ShardHashes.

ShardHashes is represented by a
dictionary with 32-bit workchain\_ids as keys, and “shard binary trees”, represented by TL-B type BinTree ShardDescr, as values. Each leaf of this
shard binary tree contains a value of type ShardDescr, which describes a single shard by indicating the sequence number seq\_no, the logical time lt, and
the hash hash of the latest (signed) block of the corresponding shardchain.

```
bt_leaf$0 {X:Type} leaf:X = BinTree X;
bt_fork$1 {X:Type} left:^(BinTree X) right:^(BinTree X)
= BinTree X;
fsm_none$0 = FutureSplitMerge;
fsm_split$10 mc_seqno:uint32 = FutureSplitMerge;
fsm_merge$11 mc_seqno:uint32 = FutureSplitMerge;
shard_descr$_ seq_no:uint32 lt:uint64 hash:uint256
split_merge_at:FutureSplitMerge = ShardDescr;
_ (HashmapE 32 ^(BinTree ShardDescr)) = ShardHashes;
```

Fields mc\_seqno of fsm\_split and fsm\_merge are used to signal future shard
merge or split events. Shardchain blocks referring to masterchain blocks with
sequence numbers up to, but not including, the one indicated in mc\_seqno are
generated in the usual way. Once the indicated sequence number is reached,
a shard merge or split event must occur.
Notice that the masterchain itself is omitted from ShardHashes (i.e., 32-
bit index −1 is absent from this dictionary).

### 5.2.4. Description of ShardFees.

ShardFees is a masterchain structure
used to reflect the total fees collected so far by the validators of a shardchain.
The total fees reflected in this structure are accumulated in the masterchain
by crediting them to a special account, whose address is a configurable parameter. Typically this account is the smart contract that computes and
distributes the rewards to all validators.

```
bta_leaf$0 {X:Type} {Y:Type} leaf:X extra:Y = BinTreeAug X Y;
bta_fork$1 {X:Type} {Y:Type} left:^(BinTreeAug X Y)
right:^(BinTreeAug X Y) extra:Y = BinTreeAug X Y;
_ (HashmapAugE 32 ^(BinTreeAug True CurrencyCollection)
CurrencyCollection) = ShardFees;
```

The structure of ShardFees is similar to that of ShardHashes (cf. 5.2.3), but
the dictionary and binary trees involved are augmented by currency values,
equal to the total\_validator\_fees values of the final states of the corresponding shardchain blocks. The value aggregated at the root of ShardFees
is added together with the total\_validator\_fees of the masterchain state,
yielding the total TON Blockchain validator fees. The increase of the value
aggregated at the root of ShardFees from the initial to the final state of a
masterchain block is reflected in the fees\_imported in the value flow of that
masterchain block.

### 5.2.5. Description of ConfigParams.

Recall that the configurable parameters or the configuration dictionary is a dictionary config with 32-bit
keys kept inside the first cell reference of the persistent data of the configuration smart contract γ (cf. 1.6). The address γ of the configuration smart
contract and a copy of the configuration dictionary are duplicated in fields
config\_addr and config of a ConfigParams structure, explicitly included
into masterchain state to facilitate access to the current values of the configurable parameters (cf. 1.6.3):

```
_ config_addr:uint256 config:^(Hashmap 32 ^Cell)
= ConfigParams;
```

### 5.2.6. Masterchain state data.

The data specific to the masterchain state
is collected into McStateExtra, already mentioned in 5.1.4:

```
masterchain_state_extra#cc1f
shard_hashes:ShardHashes
shard_fees:ShardFees
config:ConfigParams
= McStateExtra;
```

### 5.2.7. Masterchain block data.

Similarly, the data specific to the masterchain blocks is collected into McBlockExtra:

```
masterchain_block_extra#cc9f
shard_hashes:ShardHashes
= McBlockExtra;
```

# 5.3 Serialization of a bag of cells

The description provided in the previous section defines the way a shardchain
block is represented as a tree of cells. However, this tree of cells needs to
be serialized into a file, suitable for disk storage or network transfer. This
section discusses the standard ways of serializing a tree, a DAG, or a bag of
cells into an octet string.

### 5.3.1. Transforming a tree of cells into a bag of cells.

Recall that
values of arbitrary (dependent) algebraic data types are represented in the
TON Blockchain by trees of cells. Such a tree of cells is transformed into a
directed acyclic graph, or DAG, of cells, by identifying identical cells in the
tree. After that, we might replace each of the references of each cell by the
32-byte representation hash of the cell referred to and obtain a bag of cells.
By convention, the root of the original tree of cells is a marked element of the
resulting bag of cells, so that anybody receiving this bag of cells and knowing
the marked element can reconstruct the original DAG of cells, hence also the
original tree of cells.

### 5.3.2. Complete bags of cells.

Let us say that a bag of cells is complete if
it contains all cells referred to by any of its cells. In other words, a complete
bag of cells does not have any “unresolved” hash references to cells outside
that bag of cells. In most cases, we need to serialize only complete bags of
cells.

### 5.3.3. Internal references inside a bag of cells.

Let us say that a
reference of a cell c belonging to a bag of cells B is internal (with respect to
B) if the cell ci referred to by this reference belongs to B as well. Otherwise,
the reference is called external. A bag of cells is complete if and only if all
references of its constituent cells are internal.

### 5.3.4. Assigning indices to the cells from a bag of cells.

Let c0, . . . ,
cn−1 be the n distinct cells belonging to a bag of cells B. We can list these
cells in some order, and then assign indices from 0 to n − 1, so that cell ci
gets index i. Some options for ordering cells are:
• Order cells by their representation hash. Then Hash(ci) < Hash(cj )
whenever i < j.
• Topological order: if cell ci refers to cell cj
, then i < j. In general, there
is more than one topological order for the same bag of cells. There are
two standard ways for constructing topological orders:
– Depth-first order: apply a depth-first search to the directed acyclic
graph of cells starting from its root (i.e., marked cell), and list cells
in the order they are visited.
– Breadth-first order: same as above, but applying a breadth-first
search.
Notice that the topological order always assigns index 0 to the root cell of a
bag of cells constructed from a tree of cells. In most cases, we opt to use a
topological order, or the depth-first order if we want to be more specific.
If cells are listed in a topological order, then the verification that there
are no cyclic references in a bag of cells is immediate. On the other hand,
ordering cells by their representation hash simplifies the verification that
there are no duplicates in a serialized bag of cells.

### 5.3.5. Outline of serialization process.

The serialization process of a
bag of cells B consisting of n cells can be outlined as follows:

1. List the cells from B in a topological order: c0, c1, . . . , cn−1. Then c0
   is the root cell of B.
2. Choose an integer s, such that n ≤ 2
   s
   . Represent each cell ci by an
   integral number of octets in the standard way (cf. 1.1.3 or \[4, 3.1.4]),
   but using unsigned big-endian s-bit integer j instead of hash Hash(cj )
   to represent internal references to cell cj (cf. 5.3.6 below).
3. Concatenate the representations of cells ci thus obtained in the increasing order of i.
4. Optionally, an index can be constructed that consists of n + 1 t-bit
   integer entries L0, . . . , Ln, where Li
   is the total length (in octets) of
   the representations of cells cj with j ≤ i, and integer t ≥ 0 is chosen so
   that Ln ≤ 2
   t
   .
5. The serialization of the bag of cells now consists of a magic number
   indicating the precise format of the serialization, followed by integers
   s ≥ 0, t ≥ 0, n ≤ 2
   s
   , an optional index consisting of d(n+1)t/8e octets,
   and Ln octets with the cell representations.
6. An optional CRC32 may be appended to the serialization for integrity
   verification purposes.
   If an index is included, any cell ci
   in the serialized bag of cells may be easily
   accessed by its index i without deserializing all other cells, or even without
   loading the entire serialized bag of cells in memory.

### 5.3.6. Serialization of one cell from a bag of cells.

More precisely, each
individual cell c = ci
is serialized as follows, provided s is a multiple of eight
(usually s = 8, 16, 24, or 32):

1. Two descriptor bytes d1 and d2 are computed similarly to \[4, 3.1.4] by
   setting d1 = r + 8s + 16h + 32l and d2 = bb/8c + db/8c, where:
   • 0 ≤ r ≤ 4 is the number of cell references present in cell c; if c is
   absent from the bag of cells being serialized and is represented by
   its hashes only, then r = 7.
   38
   • 0 ≤ b ≤ 1023 is the number of data bits in cell c.
   • 0 ≤ l ≤ 3 is the level of cell c (cf. \[4, 3.1.3]).
   • s = 1 for exotic cells and s = 0 for ordinary cells.
   • h = 1 if the cell’s hashes are explicitly included into the serialization; otherwise, h = 0. (When r = 7, we must always have
   h = 1.)
   For absent cells (i.e., external references), only d1 is present, always
   equal to 23 + 32l.
2. Two bytes d1 and d2 (if r < 7) or one byte d1 (if r = 7) begin the
   serialization of cell c.
3. If h = 1, the serialization is continued by l + 1 32-byte higher hashes
   of c (cf. \[4, 3.1.6]): Hash1(c), . . . , Hashl+1(c) = Hash∞(c).
4. After that, db/8e data bytes are serialized, by splitting b data bits into
   8-bit groups and interpreting each group as a big-endian integer in the
   range 0 . . . 255. If b is not divisible by 8, then the data bits are first
   augmented by one binary 1 and up to six binary 0, so as to make the
   number of data bits divisible by eight.39
5. Finally, r cell references to cells cj1
   , . . . , cjr are encoded by means of r
   s-bit big-endian integers j1, . . . , jr.
   40

### 5.3.7. A classification of serialization schemes for bags of cells.

A
serialization scheme for a bag of cells must specify the following parameters:
• The 4-byte magic number prepended to the serialization.
• The number of bits s used to represent cell indices. Usually s is a
multiple of eight (e.g., 8, 16, 24, or 32).
• The number of bits t used to represent offsets of cell serializations
(cf. 5.3.5). Usually t is also a multiple of eight.
• A flag indicating whether an index with offsets L0, . . . , Ln of cell serializations is present. This flag may be combined with t by setting t = 0
when the index is absent.
• A flag indicating whether the CRC32-C of the whole serialization is
appended to it for integrity verification purposes.

### 5.3.8. Fields present in the serialization of a bag of cells.

In addition
to the values listed in 5.3.7, fixed by the choice of a serialization scheme
for bags of cells, the serialization of a specific bag of cells must specify the
following parameters:
• The total number of cells n present in the serialization.
• The number of “root cells” k ≤ n present in the serialization. The root
cells themselves are c0, . . . , ck−1. All other cells present in the bag of
cells are expected to be reachable by chains of references starting from
the root cells.
• The number of “absent cells” l ≤ n − k, which represent cells that are
actually absent from this bag of cells, but are referred to from it. The
absent cells themselves are represented by cn−l
, . . . , cn−1, and only
these cells may (and also must) have r = 7. Complete bags of cells
have l = 0.
• The total length in bytes Ln of the serialization of all cells. If the index
is present, Ln might not be stored explicitly since it can be recovered
as the last entry of the index.

### 5.3.9. TL-B scheme for serializing bags of cells.

Several TL-B constructors can be used to serialize bags of cells into octet (i.e., 8-bit byte)
sequences. The only one that is currently used to serialize new bags of cell is

```
serialized_boc#b5ee9c72 has_idx:(## 1) has_crc32c:(## 1)
has_cache_bits:(## 1) flags:(## 2) { flags = 0 }
size:(## 3) { size <= 4 }
off_bytes:(## 8) { off_bytes <= 8 }
cells:(##(size * 8))
roots:(##(size * 8)) { roots >= 1 }
absent:(##(size * 8)) { roots + absent <= cells }
tot_cells_size:(##(off_bytes * 8))
root_list:(roots * ##(size * 8))
index:has_idx?(cells * ##(off_bytes * 8))
cell_data:(tot_cells_size * [ uint8 ])
crc32c:has_crc32c?uint32
= BagOfCells;
```

Field cells is n, roots is k, absent is l, and tot\_cells\_size is Ln (the total
size of the serialization of all cells in bytes). If an index is present, parameters
s/8 and t/8 are serialized separately as size and off\_bytes, respectively,
and the flag has\_idx is set. The index itself is contained in index, present
only if has\_idx is set. The field root\_list contains the (zero-based) indices
of the root nodes of the bag of cells.
Two older constructors are still supported in the bag-of-cells deserialization functions:

```
serialized_boc_idx#68ff65f3 size:(## 8) { size <= 4 }
off_bytes:(## 8) { off_bytes <= 8 }
cells:(##(size * 8))
roots:(##(size * 8)) { roots = 1 }
absent:(##(size * 8)) { roots + absent <= cells }
tot_cells_size:(##(off_bytes * 8))
index:(cells * ##(off_bytes * 8))
cell_data:(tot_cells_size * [ uint8 ])
= BagOfCells;
serialized_boc_idx_crc32c#acc3a728 size:(## 8) { size <= 4 }
off_bytes:(## 8) { off_bytes <= 8 }
cells:(##(size * 8))
roots:(##(size * 8)) { roots = 1 }
absent:(##(size * 8)) { roots + absent <= cells }
tot_cells_size:(##(off_bytes * 8))
index:(cells * ##(off_bytes * 8))
cell_data:(tot_cells_size * [ uint8 ])
crc32c:uint32 = BagOfCells;
```

### 5.3.10. Storing compiled TVM code in files.

Notice that the above
procedure for serializing bags of cells may be used to serialize compiled smart
contracts and other TVM code. One must define a TL-B constructor similar
to the following:

```
compiled_smart_contract
compiled_at:uint32 code:^Cell data:^Cell
description:(Maybe ^TinyString)
_:^[ source_file:(Maybe ^TinyString)
compiler_version:(Maybe ^TinyString) ]
= CompiledSmartContract;
tiny_string#_ len:(#<= 126) str:(len * [ uint8 ]) = TinyString;
```

Then a compiled smart contract may be represented by a value of type CompiledSmartContract, transformed into a tree of cells and then into a bag of
cells, and then serialized using one of the constructors listed in 5.3.9. The
resulting octet string may be then written into a file with suffix .tvc (“TVM
smart contract”), and this file may be used to distribute the compiled smart
contract, download it into a wallet application for deploying into the TON
Blockchain, and so on.

### 5.3.11. Merkle hashes for an octet string.

On some occasions, we must
define a Merkle hash HashM(s) of an arbitrary octet string s of length |s|.
We do this as follows:
• If |s| ≤ 256 octets, then the Merkle hash of s is just its sha256:
HashM(s) := sha256(s) if |s| ≤ 256. (19)
• If |s| > 256, let n = 2k be the largest power of two less than |s| (i.e.,
k := blog2
(|s| − 1)c, n := 2k
). If s
0
is the prefix of s of length n, and s
00
is the suffix of s of length |s| − n, so that s is the concatenation s
0
.s00
of s
0 and s
00, we define
HashM(s) := sha256
int64(|s|). HashM(s
0
). HashM(s
00\)

(20)
In other words, we concatenate the 64-bit big-endian representation
of |s| and the recursively computed Merkle hashes of s
0 and s
00, and
compute sha256 of the resulting string.
One can check that HashM(s) = HashM(t) for octet strings s and t of length
less than 2
64 − 2
56 implies s = t unless a hash collision for sha256 has been
found.

### 5.3.12. The serialization hash of a block.

The construction of 5.3.11
is applied in particular to the serialization of the bag of cells representing an
unsigned shardchain or masterchain block. The validators sign not only the
representation hash of the unsigned block, but also the “serialization hash”
of the unsigned block, defined as HashM of the serialization of the unsigned
block. In this way, the validators certify that this octet string is indeed a
serialization of the corresponding block.

Of course. Here's that appendix on Elliptic Curve Cryptography, formatted in pure Markdown for clarity and readability.

# A. Elliptic Curve Cryptography

This appendix contains a formal description of the elliptic curve cryptography currently used in TON, particularly in the TON Blockchain and the TON Network.

TON uses two forms of elliptic curve cryptography: **Ed25519** is used for cryptographic Schnorr signatures, while **Curve25519** is used for asymmetric cryptography. These curves are used in the standard way (as defined in the original articles by D. Bernstein and RFCs 7748 and 8032); however, some serialization details specific to TON must be explained. One unique adaptation of these curves for TON is that TON supports automatic conversion of Ed25519 keys into Curve25519 keys, so that the same keys can be used for signatures and for asymmetric cryptography.

-----

## A.1 Elliptic curves

Some general facts on elliptic curves over finite fields, relevant for elliptic curve cryptography, are collected in this section.

### A.1.1 Finite fields

We consider elliptic curves over finite fields. For the purposes of the Curve25519 and Ed25519 algorithms, we will be mostly concerned with elliptic curves over the finite prime field `k := Fp` of residues modulo `p`, where `p = 2^255 − 19` is a prime number, and over finite extensions `Fq` of `Fp`, especially the quadratic extension `Fp^2`.[^1]

### A.1.2 Elliptic curves

An elliptic curve `E = (E, O)` over a field `k` is a geometrically integral smooth projective curve `E/k` of genus `g = 1`, along with a marked k-rational point `O` in `E(k)`. It is well-known that an elliptic curve `E` over a field `k` can be represented in (generalized) Weierstrass form:

```
y^2 + a1*x*y + a3*y = x^3 + a2*x^2 + a4*x + a6  (21)
```

...for some `a1, ..., a6` in `k`.

More precisely, this is only the affine part of the elliptic curve, written in coordinates `(x, y)`. For any field extension `K` of `k`, `E(K)` consists of all solutions `(x, y)` in `K^2` of equation (21), called finite points of `E(K)`, along with a point at infinity, which is the marked point `O`.

### A.1.3 Weierstrass form in homogeneous coordinates

In homogeneous coordinates `[X : Y : Z]`, equation (21) corresponds to:

```
Y^2*Z + a1*X*Y*Z + a3*Y*Z^2 = X^3 + a2*X^2*Z + a4*X*Z^2 + a6*Z^3  (22)
```

When `Z != 0`, we can set `x := X/Z`, `y := Y/Z`, and obtain a solution `(x, y)` of (21). The only solution (up to proportionality) of (22) with `Z = 0` is `[0 : 1 : 0]`; this is the point at infinity `O`.

### A.1.4 Standard Weierstrass form

When the characteristic `char k` of field `k` is not 2 or 3, the Weierstrass form can be simplified to:

```
y^2 = x^3 + a4*x + a6  (23)
```

Such an equation defines an elliptic curve if and only if the cubic polynomial `P(x) := x^3 + a4*x + a6` has no multiple roots.

### A.1.5 Addition of points on an elliptic curve

Any line intersects an elliptic curve at exactly three points `P, Q, R` (counted with multiplicities). The addition rule is defined by the requirement that `P + Q + R = O` (where `O` is the neutral element, the point at infinity) whenever `P, Q, R` lie on the same line. This defines a unique commutative group law on the points of the curve.

### A.1.6 Power maps

Since the points form a group, we can define multiples or "powers" of a point `X`, denoted `[n]X` for any integer `n`. For example, `[2]X = X + X`. This operation is a homomorphism, meaning `[n](P + Q) = [n]P + [n]Q`.

### A.1.7 The order of the group of rational points

For an elliptic curve over a finite field `Fq`, the set of points `E(Fq)` forms a finite abelian group. The order of this group (number of points) `n` is close to `q`:
`n = |E(Fq)| = q - t + 1`, where `|t| <= 2*sqrt(q)`.

### A.1.8 Cyclic subgroups of large prime order

Elliptic curve cryptography typically uses a cyclic subgroup of a large prime order `l`. A generator `G` is chosen such that `[l]G = O` but `G != O`. The integer `c` where `n = c*l` is called the **cofactor** and is usually desired to be small.

### A.1.9 Data for elliptic curve cryptography

To define a specific scheme, one must fix:

  * A finite base field `Fq`.
  * An elliptic curve `E/Fq`.
  * A base point `O` (usually the point at infinity).
  * A generator `G` of a cyclic subgroup of large prime order `l`.

### A.1.10 Main operations of elliptic curve cryptography

The main operations are the addition of points and the computation of multiples (`[n]X`). The difficulty of finding `n` given `X` and `G` (the discrete logarithm problem) is the basis of its security.

### A.1.11 Private and public keys

  * A **private key** is typically a random integer `a` (where `0 < a < l`), called the secret exponent.
  * The corresponding **public key** is the point `A := [a]G`.

### A.1.12 Montgomery curves

These are a special form of elliptic curve with the equation:

```
y^2 = x^3 + A*x^2 + x  (29)
```

They are important because they allow for a very efficient algorithm, the **Montgomery ladder**, for computing the x-coordinate of `[n]P`.

-----

## A.2 Curve25519 cryptography

This section describes the well-known Curve25519 cryptography and its usage in TON.

### A.2.1 Curve25519

Curve25519 is the Montgomery curve `y^2 = x^3 + 486662*x^2 + x` over the prime field `Fp` where `p = 2^255 - 19`. The base point `G` has an x-coordinate `x_G = 9`. Its order is `8*l` where `l` is a large prime, so the cofactor is 8.

### A.2.2 Parameters of Curve25519

  * **Base field**: `Fp` for `p = 2^255 - 19`.
  * **Equation**: `y^2 = x^3 + 486662*x^2 + x`.
  * **Base point G**: Characterized by `x_G = 9`.
  * **Order**: `8 * l`, where `l` is the prime `2^252 + 2774...`.

### A.2.3 Private and public keys for standard Curve25519

In standard Curve25519, the private key is a secret exponent `a`, and the public key is the x-coordinate of `A := [a]G`. This is used for key exchange protocols like Diffie-Hellman.

### A.2.4 Public and private keys for TON Curve25519

TON adapts the key generation from Ed25519:

  * A **private key** is a random 256-bit string `k`.
  * `sha512(k)` is computed. The first 256 bits are used to derive a secret exponent `a`. The remaining 256 bits form a secret salt `k_00`.
  * The **public key** is the x-coordinate of `A := [a]G`.

### A.2.5 Curve25519 is used in the TON Network

The asymmetric cryptography of Curve25519 is used extensively in the TON Network, particularly for the ADNL protocol. For digital signatures, however, TON Blockchain uses Ed25519.

-----

## A.3 Ed25519 cryptography

Ed25519 is used for fast cryptographic signatures in both the TON Blockchain and TON Network.

### A.3.1 Twisted Edwards curves

A twisted Edwards curve is given by the equation:

```
a*x^2 + y^2 = 1 + d*x^2*y^2  (36)
```

### A.3.2 Birational Equivalence

Twisted Edwards curves are birationally equivalent to Montgomery curves, meaning there's a mapping that can convert points from one curve type to the other.

### A.3.3 and A.3.4 Addition of points on a twisted Edwards curve

The addition of points on these curves can be computed very efficiently with simple formulas, which is why they are used for high-speed cryptography.

### A.3.5 Ed25519 twisted Edwards curve

The **Ed25519** curve is a specific twisted Edwards curve that is birationally equivalent to the **Curve25519** curve. This means computations can be performed on either curve and the results converted, allowing the same keys to be used for both signing (Ed25519) and encryption (Curve25519).

### A.3.6 Generator of Ed25519

The generator `G0` for Ed25519 corresponds to the generator `G` for Curve25519, so `[a]G0` on Ed25519 corresponds to `[a]G` on Curve25519.

### A.3.7 Standard representation of points on Ed25519

A point `P(x, y)` is compactly represented as a single 256-bit integer. The 255 lower bits store the y-coordinate, and the final bit stores the sign (even/odd) of the x-coordinate.

### A.3.8 Private key for Ed25519

The private key generation is identical to the TON method for Curve25519: a 256-bit string `k` is hashed to produce a secret exponent `a` and a secret salt.

### A.3.9 Public key for Ed25519

The public key is the standard representation of the point `A = [a]G0`. Because of the equivalence, an Ed25519 public key can be converted to a Curve25519 public key, and vice versa. Private keys require no transformation.

### A.3.10 Cryptographic Ed25519-signatures

To sign a message `M` with a private key `k`:

1.  A value `r` is computed from the hash of the secret salt and the message `M`.
2.  A point `R := [r]G0` is calculated.
3.  A value `s` is computed using `r`, the secret exponent `a`, and the hash of `R`, the public key `A`, and the message `M`.
4.  The signature is the pair `(R, s)`.

### A.3.11 Checking Ed25519-signatures

To verify a signature `(R, s)` for a message `M` with a public key `A`, one must check if the point `[s]G0` is equal to the point `R + [hash(R|A|M)]A`. If they are the same, the signature is valid.
