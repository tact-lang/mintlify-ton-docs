---
title: "Execution phases and fees"
---

import { FeePlayground } from '/snippets/feePlayground.jsx';
import { Aside } from '/snippets/aside.jsx';

# Transactions and phases

When an event occurs on an account in The Open Network (TON) blockchain, it triggers a **transaction**.  
The most common event is receiving a message, but other events like `tick-tock`, `merge`, and `split` can also initiate transactions.

Each transaction consists of up to five phases:

1. **Storage phase**: calculates storage fees for the contract based on the space it occupies in the blockchain state.
2. **Credit phase**: updates the contract balance by accounting for incoming message values and storage fees.
3. **Compute phase**: executes the contract code on the TON Virtual Machine (TVM). The result includes `exit_code`, `actions`, `gas_details`, `new_storage`, and other data.
4. **Action phase**: processes actions from the compute phase if it succeeds.  
Actions may include sending messages, updating contract code, or modifying libraries. If an action fails (for example, due to a lack of funds), the transaction may revert or skip the action, depending on its mode. For example, `mode = 0, flag = 2` means that any errors arising while processing this message during the action phase are ignored.
5. **Bounce phase**: if the compute or action phase ends with an error and the inbound message has the bounce flag set, this phase generates a bounce message.

## Gas

All computation is measured in gas units; each TVM operation has a fixed gas cost. The gas price is defined by network configuration and is not set by users (there is no fee market).

- Basechain: 1 gas = `26214400 / 2^16` nanotons = 0.0000004 TON
- Masterchain: 1 gas = `655360000 / 2^16` nanotons = 0.00001 TON

See config parameters `20` and `21` for current gas prices (for example, `https://tonviewer.com/config#20`, `https://tonviewer.com/config#21`). The values can change through validator governance.

## Compute phase

The compute phase involves executing the contract code on TVM.

<Aside type="note" title="Background">
See section 4.3.5 of the [TON whitepaper](/resources/pdfs/tblkch.pdf). It may include outdated information.
</Aside>

### When the compute phase is skipped

The compute phase may be skipped under certain conditions, such as when the account is missing, uninitialized, or frozen, or when the incoming message lacks code or data fields. These scenarios are represented by specific constructors:

- `cskip_no_state$00`: the account or message lacks a valid state,  
for example, [missing code or data](https://testnet.tonviewer.com/transaction/7e78394d082882375a5d21affa6397dec60fc5a3ecbea87f401b0e460fb5c80c).
- `cskip_bad_state$01`: the message contains an invalid state,  
for example, incorrect state for a frozen or uninitialized account.
- `cskip_no_gas$10`: the account lacks enough funds to cover gas costs.

# Fee calculation

Verify the attached Toncoin covers storage, import, compute, action, and forwarding fees. Then calculate the transaction fee.

<Aside type="note" title="Reference">
For a comprehensive list of TVM opcodes, refer to [TVM instructions](/tvm/instructions).
</Aside>

## Basic fees formula

Fees on TON are calculated using this formula:

```cpp title="FORMULAS"
transaction_fee = storage_fees
                + in_fwd_fees // also called import fee
                + computation_fees
                + action_fees
                + out_fwd_fees
```

## Fee calculator

<FeePlayground />
The calculator above works as follows under the hood:

```jsx title="Fee calculation example" expandable
// Variable names below mirror fields of config param 25 (fees).
// See: https://tonviewer.com/config#25
const lump_price = 400000;
const bit_price = 26214400;
const cell_price = 2621440000;
const ihr_price_factor = 98304;
const first_frac = 21845;
const nano = 10 ** -9;
const bit16 = 2 ** 16;
const ihr_disabled = 0; // First, define whether IHR will be counted

// Calculations
let fwd_fee =
  lump_price + Math.ceil((bit_price * 0 + cell_price * 0) / bit16);

let ihr_fee;
if (ihr_disabled) {
  ihr_fee = 0;
} else {
  ihr_fee = Math.ceil((fwd_fee * ihr_price_factor) / bit16);
}

let total_fwd_fees = fwd_fee + ihr_fee;
let gas_fees = 0.0011976; // Gas fees are out of scope here
let storage_fees = 0.000000003; // Storage fees as well
let total_action_fees = +((fwd_fee * first_frac) / bit16).toFixed(9);
let import_fee =
  lump_price + Math.ceil((bit_price * 528 + cell_price * 1) / bit16);
let total_fee =
  gas_fees +
  storage_fees +
  // total_action_fees * nano + <- already included in total_fwd_fees
  import_fee * nano +
  total_fwd_fees * nano; // <- not included in explorer's total fee

// Results
console.log("Total fee:", total_fee.toFixed(9), "Toncoin");
console.log("Action fee:", (total_action_fees * nano).toFixed(9), "Toncoin");
console.log("Forwarding fee:", (total_fwd_fees * nano).toFixed(9), "Toncoin");
console.log("Import fee:", (import_fee * nano).toFixed(9), "Toncoin");
console.log("IHR fee:", (ihr_fee * nano).toFixed(9), "Toncoin");

// Example transaction with such fees: https://txtracer.ton.org/?tx=b5e14a9c4a4e982fda42d6079c3f84fa48e76497a8f3fca872f9a3737f1f6262
```

## Elements of the transaction fee

- `storage_fees` is the amount you pay for storing a smart contract on the blockchain. In fact, you pay for every second the smart contract is stored on the blockchain.
  - _Example_: your TON wallet is also a smart contract, and it pays a storage fee every time you receive or send a transaction.
- `in_fwd_fees` is a charge for importing messages only from outside the blockchain, for example, `external` messages. Every time you make a transaction, it must be delivered to the validators who will process it. For ordinary messages from contract to contract, this fee does not apply. Read [the TON Blockchain paper](/resources/pdfs/tblkch.pdf) to learn more about inbound messages.
  - _Example_: each transaction you make with your wallet app (like Tonkeeper) must first be distributed among validators.
- `computation_fees` is the amount you pay for executing code in the virtual machine. Computation fees depend on executed operations (gas used), not code size.
  - _Example_: each time you send a transaction with your wallet (which is a smart contract), you execute the code of your wallet contract and pay for it.
- `action_fees` is a charge for sending outgoing messages made by a smart contract, updating the smart contract code, updating libraries, etc.
- `out_fwd_fees` is a charge for forwarding outgoing internal messages within TON between shardchains; it depends on message size and routing via Hypercube Routing (HR) or Instant Hypercube Routing (IHR).

## Storage fee

### Overview

In short, storage fees are the costs of storing a smart contract on the blockchain. You pay for every second the smart contract remains stored on the blockchain.

Use the [`GETSTORAGEFEE`](/tvm/instructions) opcode.

<Aside type="note" title="Deduplication">
The system counts only unique hash cells for storage and forward fees. For example, it counts three identical hash cells as one. This mechanism deduplicates data by storing the content of multiple equivalent sub-cells only once, even if they are referenced across different branches. [Read more about deduplication](/tvm/serialization/library).
</Aside>

### Low-level formula

Approximate storage fees for smart contracts (values are defined in network config param 18):

```cpp title="FORMULAS"
storage_fee = ceil(
                   (account.bits * bit_price
                   + account.cells * cell_price)
                * time_delta / 2^16)
```

### Calculation flow

Each contract has its own balance. You can calculate how many TON your contract requires to remain valid for a specified `seconds` duration using the function:

```func wrap
int get_storage_fee(int is_mc, int seconds, int bits, int cells) asm(cells bits seconds is_mc) "GETSTORAGEFEE";
```

You can then hardcode this value into the contract and calculate the current storage fee using:

```func wrap
;; functions from the FunC stdlib
() raw_reserve(int amount, int mode) impure asm "RAWRESERVE";
int get_storage_fee(int is_mc, int seconds, int bits, int cells) asm(cells bits seconds is_mc) "GETSTORAGEFEE";
int my_storage_due() asm "DUEPAYMENT";

;; constants from stdlib
;;; Creates an output action which reserves exactly x nanotons (if y = 0).
const int RESERVE_REGULAR = 0;
;;; Creates an output action which reserves at most x nanotons (if y = 2).
;;; Bit +2 in y ensures the external action does not fail if the specified amount cannot be reserved. Instead, it reserves all remaining balance.
const int RESERVE_AT_MOST = 2;
;;; In the case of action failure, the transaction is bounced. No effect if RESERVE_AT_MOST (+2) is used. TVM UPGRADE 2023-07.
const int RESERVE_BOUNCE_ON_ACTION_FAIL = 16;

() calculate_and_reserve_at_most_storage_fee(int balance, int msg_value, int workchain, int seconds, int bits, int cells) inline {
 int on_balance_before_msg = my_ton_balance - msg_value;
 int min_storage_fee = get_storage_fee(workchain, seconds, bits, cells); ;; You can hardcode this value if the contract code will not be updated.
 raw_reserve(max(on_balance_before_msg, min_storage_fee + my_storage_due()), RESERVE_AT_MOST);
}
```

If `min_storage_fee` is hardcoded, **remember to update it** during the contract update process. Not all contracts support updates, so this is an optional requirement.

## Computation fee

### Overview

In most cases, use the [`GETGASFEE`](/tvm/instructions) opcode.

### Calculation flow

```func wrap
int get_compute_fee(int is_mc, int gas_used) asm(gas_used is_mc) "GETGASFEE";
```

But how do you determine `gas_used`? Through testing!

To calculate `gas_used`, you should write a test for your contract that:

1. Executes a transfer.
2. Verifies its success and retrieves the transfer details.
3. Checks the amount of gas the transfer uses for computation.

The contract's computation flow can depend on input data. You should run the contract in a way that maximizes gas usage. Ensure you are using the most computationally expensive path to test the contract.

```ts expandable
// Initialization code
const deployerJettonWallet = await userWallet(deployer.address);
let initialJettonBalance = await deployerJettonWallet.getJettonBalance();
const notDeployerJettonWallet = await userWallet(notDeployer.address);
let initialJettonBalance2 = await notDeployerJettonWallet.getJettonBalance();
let sentAmount = toNano("0.5");
let forwardAmount = toNano("0.05");
let forwardPayload = beginCell().storeUint(0x1234567890abcdefn, 128).endCell();
// Ensure the payload is unique to charge cell loading for each payload.
let customPayload = beginCell().storeUint(0xfedcba0987654321n, 128).endCell();

// Let's use this case for fee calculation
// Embed the forward payload into the custom payload to ensure maximum gas usage during computation
const sendResult = await deployerJettonWallet.sendTransfer(
  deployer.getSender(),
  toNano("0.17"), // TON
  sentAmount,
  notDeployer.address,
  deployer.address,
  customPayload,
  forwardAmount,
  forwardPayload
);
expect(sendResult.transactions).toHaveTransaction({
  // excesses
  from: notDeployerJettonWallet.address,
  to: deployer.address,
});
/*
transfer_notification#7362d09c query_id:uint64 amount:(VarUInteger 16)
 sender:MsgAddress forward_payload:(Either Cell ^Cell)
 = InternalMsgBody;
*/
expect(sendResult.transactions).toHaveTransaction({
  // notification
  from: notDeployerJettonWallet.address,
  to: notDeployer.address,
  value: forwardAmount,
  body: beginCell()
    .storeUint(Op.transfer_notification, 32)
    .storeUint(0, 64) // default queryId
    .storeCoins(sentAmount)
    .storeAddress(deployer.address)
    .storeUint(1, 1)
    .storeRef(forwardPayload)
    .endCell(),
});
const transferTx = findTransactionRequired(sendResult.transactions, {
  on: deployerJettonWallet.address,
  from: deployer.address,
  op: Op.transfer,
  success: true,
});

let computedGeneric: (transaction: Transaction) => TransactionComputeVm;
computedGeneric = (transaction) => {
  if (transaction.description.type !== "generic")
    throw "Expected generic transaction";
  if (transaction.description.computePhase.type !== "vm")
    throw "Compute phase expected";
  return transaction.description.computePhase;
};

let printTxGasStats: (name: string, trans: Transaction) => bigint;
printTxGasStats = (name, transaction) => {
  const txComputed = computedGeneric(transaction);
  console.log(`${name} used ${txComputed.gasUsed} gas`);
  console.log(`${name} gas cost: ${txComputed.gasFees}`);
  return txComputed.gasFees;
};

const send_gas_fee = printTxGasStats("Jetton transfer", transferTx);
```

## Accept message effects

The `accept_message` and `set_gas_limit` TVM primitives control gas limits and indicate readiness to pay fees.

### External messages

- Initial gas limit is a small credit (`gas_credit` = 10,000 gas units from config `20/21`).
- During Compute, call `accept_message` to raise the gas limit to the maximum allowed (`gm`), or use `set_gas_limit(limit)` to set it to `min(limit, gm)`.
- If `gas_credit` is exhausted or you never call `accept_message`, the external message is not included in a block and no transaction is created.
- After processing, full computation fees are deducted from the contract balance (the credit is not free gas).

If an error occurs after `accept_message`:
- A transaction is recorded and fees are paid from the contract balance.
- State changes are reverted unless you committed state explicitly.
- Actions are not applied.

Security note: accepting an invalid external message and then throwing makes the contract pay and can allow replay until funds are depleted. Validate before accepting.

### Internal messages

- Default gas limit equals `message_value / gas_price`; the incoming value covers its processing.
- You may still adjust limits with `accept_message`/`set_gas_limit`.
- Bounce semantics are unaffected: a bounceable message will bounce if there is enough value to pay processing and bounce creation.

## Forward fee

### Overview

TON charges a forward fee for outgoing messages.

Generally, there are three scenarios for forward fee processing:

1. The message structure is deterministic, and you can predict the fee.
2. The message structure depends heavily on the incoming message structure.
3. You cannot predict the outgoing message structure at all.

<Aside type="note" title="Typical pattern">
In most apps, the sender:
1. Attaches enough TON to cover gas and forwarding fees to the internal message
2. Sets the bounce flag (sends a bounceable internal message)

The receiver then returns the unused portion of the received value with the answer, deducting message forwarding fees. In Jetton contracts this is typically done via `RAWRESERVE` with `SENDRAWMSG` and message modes `128/130/144`.
</Aside>

### Calculation in smart contracts

1. If the message structure is deterministic, use the [`GETFORWARDFEE`](/tvm/instructions) opcode.

<Aside type="note" title="Deduplication">
The system counts only unique hash cells for storage and forward fees. For example, it counts three identical hash cells as one. This mechanism deduplicates data by storing the content of multiple equivalent sub-cells only once, even if they are referenced across different branches. [Read more about deduplication](/tvm/serialization/library).
</Aside>

2. However, if the outgoing message depends significantly on the incoming structure, you may not be able to fully predict the fee. In such cases, try using the [`GETORIGINALFWDFEE`](/tvm/instructions) opcode.

3. The [`SENDMSG`](/tvm/instructions) opcode is the least optimal way to calculate fees, but it is better than not checking.

<Aside type="caution" title="Caution">
`SENDMSG` uses an unpredictable amount of gas.  
Prefer the methods above whenever possible.
</Aside>

Use it with a serialized message cell and a message mode.

Important modes when estimating with `SENDMSG`:

- **`+1024`**: Returns the estimated fee without creating an output action. Other modes will send a message during the action phase.
- **`+128`**: Substitutes the value of the entire contract balance before the computation phase begins. This is slightly inaccurate because gas expenses, which cannot be estimated before the computation phase, are excluded.
- **`+64`**: Substitutes the entire balance of the incoming message as the outgoing value. This is also slightly inaccurate, as gas expenses that cannot be estimated until the computation is completed are excluded.
- Refer to the [message modes cookbook](/ton/message-modes) for additional modes.

With modes other than `+1024`, it creates an output action and returns the fee for creating a message. With `+1024`, it only returns the estimated fee and does not create an output action. In all cases, it uses an unpredictable amount of gas, which cannot be calculated using formulas. To measure gas usage, use `GASCONSUMED`:

```func
int send_message(cell msg, int mode) impure asm "SENDMSG";
int gas_consumed() asm "GASCONSUMED";
;; ... some code ...

() calculate_forward_fee(cell msg, int mode) inline {
 int gas_before = gas_consumed();
 int forward_fee = send_message(msg, mode);
 int gas_usage = gas_consumed() - gas_before;

 ;; forward fee -- fee value
 ;; gas_usage -- the amount of gas used to send the message
}
```

### Low-level formula

Forwarding fees for a message of size `msg.bits` and `msg.cells` are computed using config params 24/25:

```cpp title="FORMULAS"
// bits in the root cell of a message are not included in msg.bits (lump_price pays for them)
msg_fwd_fees = (lump_price
             + ceil(
                (bit_price * msg.bits + cell_price * msg.cells) / 2^16)
             );

ihr_fwd_fees = ceil((msg_fwd_fees * ihr_price_factor) / 2^16);

total_fwd_fees = msg_fwd_fees + ihr_fwd_fees; // ihr_fwd_fees is 0 for external messages
```

<Aside type="info" title="Action fee relation">
`msg_fwd_fees` already includes the action fee for the corresponding `SENDRAWMSG`. For a basic internal message with `lump_price = 400000` and `first_frac = 21845`, `action_fee ≈ 133331` nanotons and `fwd_fee ≈ 266669` nanotons.
</Aside>

## Action fee

The action fee is charged when processing the action list (after Compute). Practically, you pay it for `SENDRAWMSG`; other actions such as `RAWRESERVE` or `SETCODE` do not incur action fees.

```cpp title="FORMULAS"
action_fee = floor((msg_fwd_fees * first_frac)/ 2^16);  // internal

action_fee = msg_fwd_fees;  // external
```

`first_frac` is defined in config params 24/25 and is approximately one third (currently 21845).

Action fine (failed send): starting from Global Version 4, if a "send message" action fails, the account pays a fine proportional to the attempted message size:

```cpp title="FORMULAS"
fine_per_cell = floor((cell_price >> 16) / 4)
max_cells = floor(remaining_balance / fine_per_cell)
action_fine = fine_per_cell * min(max_cells, cells_in_msg);
```

## Fees configuration

All fees are denominated in nanotons (often scaled by `2^16` for precision) and come from network configuration:

- storage_fees: param 18 (`https://tonviewer.com/config#18`)
- in_fwd_fees: params 24/25 (`https://tonviewer.com/config#24`, `https://tonviewer.com/config#25`)
- computation_fees: params 20/21 (`https://tonviewer.com/config#20`, `https://tonviewer.com/config#21`)
- action_fees: params 24/25 (`https://tonviewer.com/config#24`, `https://tonviewer.com/config#25`)
- out_fwd_fees: params 24/25 (`https://tonviewer.com/config#24`, `https://tonviewer.com/config#25`)

### Message bouncing

- If the receiver cannot parse the message and terminates with a non‑zero exit code, the message bounces back automatically.
- The bounced message has its `bounce` flag cleared and `bounced` flag set, and contains `0xffffffff` (32‑bit) followed by the original message body (256‑bit).
- Always check the `bounced` flag before parsing `op` to avoid treating a bounce as a new query.

## See also

- [Stablecoin contract with fees calculation](https://github.com/ton-blockchain/stablecoin-contract)