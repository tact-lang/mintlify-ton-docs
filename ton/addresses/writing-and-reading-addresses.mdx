title: "How to read and write TON addresses"
sidebarTitle: "Read and write TON addresses"
--------------------------------------------

- how to create and parse
- how to check the validity
- how to convert from one format to another

## Use the online converter

A user-friendly online parser and address converter on the TON Blockchain is the [TON Address tool](https://ton.org/address).
If you enter an address in any format, the tool provides all possible formats when the input is valid.
Otherwise, the tool displays a warning that the address is invalid.

![Example query in TON Address tool](/resources/images/ton-addresses.png)

## Use the SDK

There are Software Development Kits (SDKs) for interacting with the TON Blockchain, written in:

- [TypeScript](https://github.com/ton-org/ton)
- [Java](https://github.com/neodix42/ton4j)
- [Go](https://github.com/xssnick/tonutils-go)
- [Python](https://github.com/nessshon/tonutils)

You can use any of them, including for working with addresses. This guide focuses on the TypeScript SDK.
Namely, we examine [ton-core address module](https://github.com/ton-org/ton-core/tree/main/src/address).

The internal addresses are represented as instances of the `Address` class. You can access it in your integrated development environment (IDE) using the following import.
Not runnable

```typescript
import { Address } from "@ton/core";

readonly workChain: number;
readonly hash: Buffer;
```

As for the external addresses, they are represented as instances of the `ExternalAddress` class. Similarly, you can access it as follows.
Not runnable

```typescript
import { ExternalAddress } from "@ton/core";

readonly value: bigint;
readonly bits: number;
```

### Create, parse, and convert addresses

Create addresses.
Not runnable

```typescript
// There is a hash validation check inside the Address constructor.
const internalAddress = new Address(some_wc, some_valid_hash); 

const externalAddress = new ExternalAddress(some_value, some_bits);
```

You can parse an internal address string and then convert it from one format to another as follows.

```typescript
const address1 = Address.parse('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF');
const address2 = Address.parse('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e');
// or via its convenient wrapper
// const address1 = address('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF');

// const address2 = address('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e');

// these two addresses are equal
console.log(address1.equals(address2)); // true

// toString arguments: urlSafe    {true means using '-' and '_' instead of '+' and '/'; false means the opposite};
//                     bounceable {true means the address is bounceable; false means non-bounceable}; 
//                     testOnly   {true means the address is for Testnet; false means for Mainnet}. 
// default values: true, true, false.

console.log(address1.toString()); // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF
console.log(address1.toString({urlSafe: false})) // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff+W72r5gqPrHF
console.log(address1.toString({bounceable: false})) // UQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPuwA
console.log(address1.toString({testOnly: true})) // kQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPgpP
console.log(address1.toString({bounceable: false, testOnly: true})) // 0QDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPleK

// output the address in raw format
console.log(address1.toRawString()); // 0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e

// returns a Buffer with the userâ€‘friendly format address
address1.toStringBuffer();

// the same for address2
console.log(address2.toString()); // EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF
console.log(address2.toRawString()); // 0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e

// returns a Buffer with the raw format address
address2.toStringBuffer();

```

If you are sure that your string accurately represents the address in raw or user-friendly format, you can also use the following methods.

```typescript
const address1 = Address.parseFriendly('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF');
const address2 = Address.parseRaw('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e');
```

However, there is no separate method for parsing external addresses from a string.

### Validate addresses

Parsing checks address validity. Parsing an invalid address results in an error.
However, you can check separately whether a string is a valid address in raw or user-friendly formats.

```typescript
console.log(Address.isFriendly('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF')) // true
console.log(Address.isRaw('EQDKbjIcfM6ezt8KjKJJLshZJJSqX7XOA4ff-W72r5gqPrHF')) // false

console.log(Address.isFriendly('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e')) // false
console.log(Address.isRaw('0:ca6e321c7cce9ecedf0a8ca2492ec8592494aa5fb5ce0387dff96ef6af982a3e')) // true
```
