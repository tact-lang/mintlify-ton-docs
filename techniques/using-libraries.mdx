---
title: "Using libraries"
---

import { Image, ImageControls } from '/snippets/image.jsx';

Before reading this article, it is recommended to read [this article on fundamentals](ton/cells/library-cells.mdx) first.

All theoretical background is described in [this article](ton/cells/library-cells.mdx).

Everything in TON is stored in cells, even the accounts code. So one of the most common usecases for libraries is to store common code that is used by multiple contracts.
When a library cell is a part of account's `code`, it is being automatically dereferenced on the first access. So one can replace the part of the contract code, or even the whole code with a library cell.

The approach with replacing full code with a library cell is widely used in TON smart-contracts.
Some common examples:
1. USDT (and other popular Jettons) Jetton-wallets
2. Order contract in Multisig-v2 contract system.
3. NFT-item contract in popular collections.

And some other examples.

You can easily check if a contract is using a library as it's code by looking into it's `code` cell in the explorer.

<Image src="/resources/images/using-libraries/library-in-explorer.png" />

Here you can clearly see, that whole contract code is 8 bits with int equals 2 and the 256 bits - representation hash of referenced cell.

However, if for some reason you need to not want to make the whole code a library cell, you can, for example, make a part of the code a library cell. For example some function is being used in multiple different contracts. It is okay to make it a library. However, you will probably need to set-up the build process of such non-standard code by yourself.

### Economy on fees.

Library cells helps reduce fees in two main ways.

1. Reducing storage cost. But as library must be hosted in masterchain, where storage cost is 1000 times higher than in basechain, hosting a copy of a code in basechain might be cheaper, if there are less than 1000 instances of the contract. The coefficient 1000 is not a constant and a subject to change. Consult [blockchain config parameter 18](https://tonviewer.com/config#18) for the latest value.

1. Reducing forward fees. For example, in [jettons](/standard/tokens/jetton.mdx) StateInit should be forwarded on each transfer, which results in high forward fees on each transfer. Making a code library cell significantelly reduces fees.


### Using in @ton/ton

You can construct a library cell entirely in TypeScript using the `@ton/core` library. Here’s how to do it in a Blueprint project:

```ts
import { Cell, beginCell } from '@ton/core';

let lib_prep = beginCell().storeUint(2,8).storeBuffer(jwallet_code_raw.hash()).endCell();
jwallet_code = new Cell({ exotic:true, bits: lib_prep.bits, refs:lib_prep.refs});
```

- [View source](https://github.com/ton-blockchain/stablecoin-contract/blob/de08b905214eb253d27009db6a124fd1feadbf72/sandbox_tests/JettonWallet.spec.ts#L104C1-L105C90)

### Publish ordinary cell in masterchain library context

A practical example is available [here](https://github.com/ton-blockchain/multisig-contract-v2/blob/master/contracts/helper/librarian.func).

The core of this contract is the line: `set_lib_code(lib_to_publish, 2);`. This function call publishes an ordinary cell with the flag set to `2`, which indicates that the library is public and can be used by anyone.

**Note:** the contract that publishes the cell is responsible for paying its and MasterChain's storage fees. Storage costs in the MasterChain are approximately 1000 times higher than in the BaseChain. Therefore, using a library cell is only cost-effective for contracts that thousands of users utilize.

Also, another library manager contract exists an is available on [github](https://github.com/bidask-protocol/func-library-manager)

### Testing in the Blueprint

To test how contracts that use library cells work in Blueprint, manually add the referenced cells to the emulator’s library context. This can be done as follows:

1. Create a library context dictionary (a Hashmap) of type `uint256 -> Cell`, where `uint256` is the hash of the corresponding cell.
2. Set this library context in the emulator’s settings.

An example implementation can be found [here](https://github.com/ton-blockchain/stablecoin-contract/blob/de08b905214eb253d27009db6a124fd1feadbf72/sandbox_tests/JettonWallet.spec.ts#L100C9-L103C32).

### Get methods for library cell-based contracts

When working with a jetton wallet, where the code is stored in a library cell, you may need to check its balance. To do so, you must execute a get method in the code. This involves the following steps:

- Accessing the library cell
- Retrieving the hash of the referenced cell
- Finding the cell with that hash in the MasterChain's library collection
- Executing the code from there

In Liteservers (LS), all these processes happen automatically behind the scenes, and users needn’t be concerned with the specific method of code storage.

However, the process differs when working locally. For example, when using an explorer or wallet, you might examine the account state to determine its type, such as whether it's an NFT, wallet, token, or auction.

You can review regular contracts' available get methods, the contract interface, to understand how they work. Alternatively, you may take the account state to your local system and execute methods there.

This approach is not feasible for a library cell because it does not store data on its own. Instead, you must manually detect and retrieve the necessary cells from the context. This can be done using LS, though bindings do not yet support this, or via DTon.

#### Retrieving Library Cell with Liteserver

When running get methods with liteserver, the correct library context is automatically set. If you need to detect the contract type using get methods or run them locally, download the corresponding cells via the LS method [liteServer.getLibraries](https://github.com/ton-blockchain/ton/blob/4cfe1d1a96acf956e28e2bbc696a143489e23631/tl/generate/scheme/lite_api.tl#L96).
