title: "Estimate gas usage in TON contracts"
---

import {Aside} from "/snippets/aside.jsx";

Accurately estimate gas consumption by defining operation-specific constants and proving they are never exceeded through systematic testing.

## Objective

Establish gas constants for each contract operation and validate them across all execution paths to prevent out-of-gas failures.

## Core methodology

Gas estimation follows a test-driven approach:

1. Define conservative gas constants for each operation
1. Run comprehensive tests covering all execution paths
1. Extract actual gas consumption from transaction receipts
1. Verify actual usage never exceeds constants
1. Adjust constants if needed with safety margin

This ensures operations always have sufficient gas while avoiding overpayment.

## Define operation-specific constants

Create a dedicated constants file organized by functionality:

```tact
// Swap operations
const GasSwapRequest: Int = 11000;
const GasPoolSwap: Int = 12000;

// Liquidity operations
const GasLiquidityDeposit: Int = 15500;
const GasLiquidityWithdraw: Int = 9500;
```

Use descriptive names indicating the operation and contract. Jetton operations typically require 20–30% more gas than native TON operations due to additional contract calls.

## Calculate total fees

Transaction fees consist of three components:

### Compute fees

The cost of TVM execution, measured in gas units. Convert to TON at runtime using blockchain config parameters:

```tact
getComputeFee(hardcodedGasValue, isAccountInMasterchain)
```

This function uses the [`GETGASFEE`](/tvm/instructions#f836-getgasfee) TVM opcode.

### Forward fees

Message routing costs based on message size. When your outgoing message is smaller than or equal to the incoming message, read the fee from context:

```tact
let fwdFee = context().readForwardFee();
```

Fees scale with message size—if you are not adding data, the outgoing fee will not exceed the incoming fee.

For precise calculation when creating larger messages, use [`GETFORWARDFEE`](/tvm/instructions#f838-getforwardfee):

If the outgoing message size cannot be predicted at compile time, calculate its size at runtime using [`CDATASIZE`](/tvm/instructions#f941-cdatasize):

```tact
let size = computeDataSize(msg.toCell(), 65536);
let fwdFee = getForwardFee(size.cells, size.bits, isAccountInMasterchain);
```

### Storage fees

Two distinct approaches exist:

**Approach 1: Maintain a positive reserve**

Always keep a minimum balance on the contract. Storage fees deduct from this reserve, which replenishes with each user interaction.
Do not hardcode TON; instead, hardcode the maximum possible contract size in cells and bits.

```tact
const secondsInFiveYears: Int = 5 * 365 * 24 * 60 * 60;
receive(msg: Transfer) {
    let minTonsForStorage: Int = getStorageFee(maxCells, maxBits, secondsInFiveYears, isAccountInMasterchain);
    nativeReserve(minTonsForStorage, ReserveAtMost);
    // Process operation with remaining value...
}
```

<Aside>
  Verify the hardcoded contract size in tests.
</Aside>

Use this when contracts must maintain a continuous positive balance, such as jetton wallets that may sit idle for extended periods.

**Approach 2: Cover storage on demand**

Allow the balance to remain at zero or with small debt. Reserve storage debt from incoming messages when needed.

```tact
receive(msg: Operation) {
    // Process operation first...

    // Reserve original balance plus any storage debt
    nativeReserve(myStorageDue(), ReserveAddOriginalBalance | ReserveExact);

    // Send remaining value onward
    send(SendParameters{
        value: 0,
        mode: SendRemainingBalance,
        // ...
    });
}
```

This simplifies fee calculation at the start of the operation—you do not need to pre‑calculate storage fees. The `myStorageDue()` function returns the amount needed to bring the balance to zero (or zero if it is already positive).

## Implement fee validation

Check that the incoming value covers all operation costs before processing:

```tact
receive(msg: SwapRequest) {
    let ctx = context();
    let fwdFee = ctx.readForwardFee();

    // Count all messages in the operation chain
    let messageCount = 3;  // vault → pool → vault

    // Calculate minimum required
    let minFees =
        messageCount * fwdFee +
        getComputeFee(GasSwapRequest, false) +
        getComputeFee(GasPoolSwap, false) +
        minTonsForStorage;

    require(ctx.value >= msg.amount + minFees, "Insufficient TON attached");

    // Reserve swap amount and process
    nativeReserve(msg.amount, ReserveExact | ReserveAddOriginalBalance);
    // Send remaining value for fees...
}
```

Document each fee component with inline comments explaining the count and purpose. This helps future maintainers understand the calculation.

## Verify through testing

### Extract gas consumption

Create a utility to extract compute gas from transaction receipts:

```typescript
export function getComputeGasForTx(tx: Transaction): bigint {
    if (tx.description.type !== "generic") {
        throw new Error("Expected generic transaction");
    }
    if (tx.description.computePhase.type !== "vm") {
        throw new Error("Expected VM compute phase");
    }
    return tx.description.computePhase.gasUsed;
}
```

### Check every execution path

Verify gas usage for each transaction in multi‑step operations:

```typescript
async function testSwap() {
    const result = await vault.sendSwap(amount, params);

    // Find and verify each transaction
    const vaultTx = findTransactionRequired(result.transactions, {
        on: vault.address,
        op: VaultOpcodes.Swap,
    });
    expect(getComputeGasForTx(vaultTx))
        .toBeLessThanOrEqual(GasSwapRequest);

    const poolTx = findTransaction(result.transactions, {
        on: pool.address,
        op: PoolOpcodes.Swap,
    });
    expect(getComputeGasForTx(poolTx))
        .toBeLessThanOrEqual(GasPoolSwap);
}
```

### Verify balance behavior

For contracts using the zero‑balance approach, confirm there is no excess accumulation:

```typescript
it("should not accumulate excess balance", async () => {
    await pool.sendSwap(amount);

    const balance = (await blockchain.getContract(pool.address)).balance;
    expect(balance).toEqual(0n);
});
```

This confirms that all incoming value was consumed or forwarded, with none left behind. It helps identify any bugs that cause accumulation of TON on any contract.

## Common patterns

### Multi‑hop operations

Scale fees with chain length:

```tact
let totalFees =
    (hops + 2) * storageFeePerContract +
    (hops + 1) * fwdFee +
    getComputeFee(GasPerHop, false) * hops;
```

Account for both ends of the chain (hence `+ 2` for storage, `+ 1` for the final message).

<Aside type="caution">
  Verify in tests that each hop’s message size is less than or equal to the input message. Otherwise, reading the forward fee from context (`readForwardFee()`) will not be accurate.
</Aside>

### State initialization

When deploying contracts as part of the operation:

```tact
deploy(DeployParameters{
    init: initOf TargetContract(params),
    value: 0,
    mode: SendRemainingBalance,
    body: initialMessage.toCell(),
});
```

The `init` field adds significant message size (the size of a forwarded `StateInit` also affects forward fees). Calculate its forward fee separately using actual cell/bit counts with `getForwardFee` / `getSimpleForwardFee`.

## See also

- [Phases and fees](/ton/phases-and-fees) — TON fee structure and components
- [TVM instructions](/tvm/instructions) — Reference for `GETGASFEE`, `GETFORWARDFEE`, `CDATASIZE`
