---
title: "Contract sharding"
---

Some protocols need to store a lot of information in contracts, for example tokens that have many users. In TON there is a limit on how much can be stored in a single contract. The solution in TON is to split the data across many different contracts, where you can quickly find the right contract by a key and retrieve the required information from it.

In such protocols there is a child contract that initially contains the information identified by a key. In some protocols it is important to know the Parent contract, which acts as the information manager.

To avoid having to know the key upfront, in StateInit we do not populate that field; we only populate the key field. This makes it easy to locate the required contract later.

Consider NFTs: the collection serves as the Parent contract, and the NFT items are the child contracts. The key in this case is the index, and only a message from the collection can set the initial owner.

For Jettons, the Parent is the minter and the Children are user wallets. The key is the user's address, and the value is the user's token balance.

In general, jettons and NFTs share this principle, but broadly speaking, jetton protocols have a unique contract per user, while NFTs have a single contract per item (by index) that is shared across all users.

![Shard pattern pic](/techniques/pictures/shardPattern.jpg)